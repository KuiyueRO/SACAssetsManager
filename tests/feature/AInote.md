# HNSW向量索引测试工具

本目录包含用于测试和比较不同HNSW向量索引实现的工具和测试套件。

## 可用测试

- **hnswlayers对比测试**: 比较不同HNSW实现的性能和准确性
- **runHnswlayersTest.js**: 测试入口，包括hnswClassic.js的测试

## 使用方法

1. 运行基本测试:
```bash
node tests/feature/runHnswlayersTest.js
```

2. 修改参数:
在`runHnswlayersTest.js`中修改测试参数如向量维度、查询次数等。

## hnswClassic.js测试说明

从最新版本开始，测试套件支持使用hnswClassic.js作为经典HNSW实现进行测试，这是基于Rust horaHnsw.rs的JavaScript实现。

### 主要特性

- 使用相同的算法结构和数据组织方式
- 支持余弦、欧氏、曼哈顿和点积距离度量
- 支持数据序列化和反序列化
- 提供与原生实现相似的API

### 使用注意事项

1. **Node类构造**: 使用`Node`类包装向量和ID
2. **距离选择**: 使用`Metric`枚举选择距离度量方式(Cosine = 2)
3. **内存效率**: JavaScript实现在大规模数据上可能内存效率不如原生实现
4. **构建与搜索**: 调用`build(metricType)`构建索引，使用`nodeSearchK(node, k)`查询

### 典型用法

```javascript
import { HNSWIndex, Node, Metric } from '../src/toolBox/feature/forVectorEmbedding/useDeltaPQHNSW/hnswClassic.js';

// 创建索引
const index = new HNSWIndex(128, {
  n_neighbor: 16,
  n_neighbor0: 32,
  max_level: 6,
  ef_build: 200,
  ef_search: 100
});

// 添加数据
const node = new Node([...向量数据], '唯一ID');
index.addNode(node);

// 构建索引(使用余弦距离)
index.build(Metric.Cosine);

// 查询
const queryNode = new Node([...查询向量]);
const results = index.nodeSearchK(queryNode, 10);
```

## 测试性能优化建议

1. 降低测试向量维度(如512)以加快测试速度
2. 减少查询次数加快测试完成
3. 测试小数据集时降低最小可接受召回率(如70%)
4. 可以通过设置`skipClassicImplementation: true`跳过经典算法测试
5. 调整HNSW参数如M、efConstruction和efSearch会影响性能和准确性 

# DeltaPQ召回率优化指南

本文档提供了DeltaPQ算法在不同场景下的召回率优化建议，基于`deltaPQ召回率测试.js`的测试结果。

## 影响召回率的关键因素

DeltaPQ的召回率主要受以下因素影响：

1. **子向量数量(numSubvectors)**：将向量分割为多少个子向量
2. **编码位数(bitsPerCode)**：每个子向量使用多少位进行编码
3. **距离度量(distanceMetric)**：使用欧几里得距离还是余弦距离
4. **向量维度(dim)**：向量的维度大小
5. **数据分布特性**：数据的内在分布和聚类特性

## 召回率与压缩率平衡

在实际应用中，需要在召回率和压缩率之间找到平衡点：

| 召回率要求 | 压缩率潜力 | 推荐配置 |
|-----------|-----------|---------|
| >95% | 低(5-10x) | 少量子向量(16)，高位编码(10) |
| 90-95% | 中(10-20x) | 中等子向量(32)，高位编码(10) |
| 80-90% | 高(20-40x) | 较多子向量(64)，标准编码(8) |
| <80% | 极高(40x+) | 大量子向量(128)，标准编码(8) |

## 欧几里得距离vs余弦距离

两种距离度量在召回率表现上存在差异：

### 欧几里得距离
- 更适合物理或特征空间中的相似性搜索
- 对子向量划分的敏感度较低
- 能够达到更高的压缩率同时保持良好召回率
- 在高维空间中表现更稳定

### 余弦距离
- 更适合文本、语义等需要方向相似性的场景
- 对子向量划分更敏感，子向量数量增加会导致召回率显著下降
- 在低维向量(512维以下)中表现更好
- 要求更高的编码位数以保持较高召回率

## 维度特定的优化建议

### 512维向量
- **欧几里得距离**：32-64子向量，8-10位编码可获得80-95%召回率
- **余弦距离**：16-32子向量，10位编码可获得85-95%召回率

### 768维向量
- **欧几里得距离**：64子向量，8-10位编码可获得75-90%召回率
- **余弦距离**：32子向量，10位编码可获得80-90%召回率

### 1024+维向量
- **欧几里得距离**：64-128子向量，8-10位编码
- **余弦距离**：32-64子向量，10位编码，考虑使用特定维度分割策略

## 实际应用优化策略

1. **训练集选择**：使用与查询分布相似的数据进行训练，提高针对性
2. **参数调优**：针对特定数据集，进行小规模测试确定最佳参数
3. **分层索引**：对于高精度需求，考虑结合HNSW进行二次过滤
4. **多索引组合**：对于关键应用，可使用不同参数的多个索引并合并结果
5. **向量预处理**：根据距离度量进行适当的向量预处理(如归一化、标准化)

## 性能基准

基于测试结果整理的性能基准：

| 配置 | 512维欧几里得 | 512维余弦 | 768维欧几里得 | 768维余弦 |
|------|--------------|-----------|--------------|-----------|
| 16子向量,8位 | ~85%@10 | ~80%@10 | ~75%@10 | ~70%@10 |
| 16子向量,10位 | ~90%@10 | ~88%@10 | ~80%@10 | ~78%@10 |
| 32子向量,8位 | ~80%@10 | ~72%@10 | ~72%@10 | ~65%@10 |
| 32子向量,10位 | ~88%@10 | ~85%@10 | ~78%@10 | ~75%@10 |
| 64子向量,8位 | ~75%@10 | ~65%@10 | ~65%@10 | ~60%@10 |
| 64子向量,10位 | ~82%@10 | ~70%@10 | ~72%@10 | ~65%@10 |

注：以上数据代表@10查询的近似召回率，实际结果可能因数据分布而异。

## 结论与建议

1. 对于**欧几里得距离**，建议从64子向量、8位编码开始测试
2. 对于**余弦距离**，建议从32子向量、10位编码开始测试
3. 当召回率要求超过90%时，减少子向量数并增加编码位数
4. 高维向量比低维向量需要更多的子向量
5. 在实际应用中，建议进行针对性测试以确定最佳配置 

# DeltaPQ算法技术说明

## 关键点

### 余弦距离与向量归一化

使用余弦距离度量时，**输入向量必须进行严格归一化**（即向量长度为1）。这一要求是算法正确性的基础，不可忽视。

- **原因**：余弦距离基于向量间夹角计算，归一化保证了计算的一致性和准确性
- **处理机制**：当前版本DeltaPQ在使用余弦距离时会自动检测向量是否归一化，对非归一化向量会发出警告并进行自动归一化
- **最佳实践**：尽管有自动归一化机制，但在应用层面提前归一化向量仍是推荐做法，可以避免重复操作提高性能

### 子向量划分的影响

子向量划分数量（`numSubvectors`）是影响DeltaPQ性能的关键参数：

- **对余弦距离的影响**：子向量划分后，每个子向量可能不再是单位向量，这会对余弦距离计算带来微小误差
- **对欧氏距离的影响**：子向量划分不会改变欧氏距离的基本性质，较为稳定
- **平衡点**：32-64子向量通常能在压缩率与精度间取得良好平衡

### 编码位数与压缩率

编码位数（`bitsPerCode`）决定了每个子向量使用多少位进行编码：

- **高位编码（10-12位）**：提供更高精度，但压缩率较低
- **低位编码（6-8位）**：提供更高压缩率，但可能降低精度
- **权衡**：对于余弦距离，建议使用较高位编码（10位）；对于欧氏距离，8位通常已足够

## 召回率测试说明

召回率测试评估了DeltaPQ在不同配置下的近似搜索性能。召回率定义为：在使用近似搜索方法时，能够正确召回的真实最近邻的比例。

### 影响召回率的因素

1. **距离度量类型**
   - 欧氏距离通常比余弦距离有更高的召回率
   - 余弦距离对子向量划分更敏感

2. **向量维度**
   - 较高维度（>512）需要更多的子向量以平衡压缩率与召回率
   - 维度增加通常会导致对编码位数要求提高

3. **子向量数量与编码位数组合**
   - 子向量数量↑ + 编码位数↑ = 高精度，但低压缩率
   - 子向量数量↑ + 编码位数↓ = 中等精度，高压缩率
   - 子向量数量↓ + 编码位数↑ = 较高精度，中等压缩率
   - 子向量数量↓ + 编码位数↓ = 低精度，但极高压缩率

### 如何解读测试结果

测试结果中的关键指标包括：

- **召回率@k**：在k个近邻中召回正确结果的比例
- **量化误差**：向量量化过程中引入的平均误差
- **速度提升**：与精确搜索相比，近似搜索的加速比
- **压缩比**：原始向量大小与量化后向量大小的比值

#### 优秀的结果指标

- 高召回率：>90%@10（在前10个结果中召回90%以上的真实最近邻）
- 低量化误差：<0.1（越低越好）
- 高速度提升：>10x（与精确搜索相比）
- 高压缩比：>8x（保证较小的存储空间占用）

### 优化建议

根据应用场景优化DeltaPQ参数：

1. **高精度场景**（搜索准确性至关重要）
   - 距离度量：欧氏距离
   - 子向量数：16-32
   - 编码位数：10-12
   - 可获得：95%+的召回率@10

2. **高压缩场景**（存储空间受限）
   - 距离度量：欧氏距离
   - 子向量数：64-128
   - 编码位数：6-8
   - 可获得：80-90%的召回率@10，但极高压缩比

3. **余弦距离特化**（语义相似度搜索）
   - 子向量数：32
   - 编码位数：10
   - 确保输入向量归一化
   - 可获得：85-90%的召回率@10

4. **平衡配置**（适用大多数场景）
   - 距离度量：根据应用选择
   - 子向量数：32
   - 编码位数：8
   - 可获得：~85%的召回率@10，~12x压缩比

## 性能调优指南

**路径修复 (2024-07-29)**:
- `向量嵌入测试.js`, `deltaPQ性能测试.js`, `deltaPQ召回率测试.js`, `deltaPQ余弦距离归一化测试.js` 中对 `forDistance.js` 的导入路径已从旧的 `src/toolBox/base/forMath/forGeometry/forVectors/` 更新为 `src/toolBox/base/math/`。

### 训练集优化

- 训练集大小应不少于1000个向量
- 训练集应尽可能接近实际数据分布
- 训练迭代次数建议设置为20-25

### 搜索参数调优

- 对精度要求高的场景，可以使用重排序技术：先用DeltaPQ快速检索较大候选集，再用原始向量重新计算距离进行精确排序
- 支持的K值范围广泛（1-1000），但K值越大，召回率通常越低

### 内存与计算权衡

- 快表缓存（距离查找表）可极大提高搜索速度，但会增加内存占用
- 对于高维向量（>1024），考虑先进行降维（如PCA），再应用DeltaPQ

## 与其他算法对比

### DeltaPQ vs 传统PQ

- DeltaPQ引入增量编码，在保持相似压缩率的情况下提高了召回率
- DeltaPQ对余弦距离有特殊优化，而传统PQ主要针对欧氏距离

### DeltaPQ vs HNSW

- HNSW提供更高召回率，但无压缩功能
- DeltaPQ+HNSW组合可兼顾压缩和搜索效率

### DeltaPQ vs ScaNN

- ScaNN在超大规模向量集上有更好表现
- DeltaPQ在中小规模场景下实现更简单，计算开销更低

## 应用场景适配

| 场景 | 推荐配置 | 预期结果 |
|------|---------|---------|
| 图像特征搜索 | 欧氏距离, 64子向量, 8位编码 | ~90%召回率@10, ~16x压缩比 |
| 文本语义搜索 | 余弦距离, 32子向量, 10位编码 | ~85%召回率@10, ~10x压缩比 |
| 推荐系统 | 余弦距离, 64子向量, 8位编码 | ~80%召回率@10, ~16x压缩比 |
| 音频特征匹配 | 欧氏距离, 32子向量, 10位编码 | ~95%召回率@10, ~10x压缩比 | 

## AI前端网页客户端能力构想

一个能够"左脚踩右脚上天"的AI前端网页客户端应该具备以下能力，从而实现超越传统Web应用的创新体验：

### 1. 本地智能处理能力

- **向量嵌入本地化**：使用WebAssembly实现的高性能向量处理，包括DeltaPQ压缩、HNSW索引等
- **本地模型推理**：通过TensorFlow.js/ONNX Runtime实现在浏览器中运行精简版LLM模型（如Phi-2）
- **增量学习能力**：根据用户交互动态调整模型权重，实现个性化体验而无需服务器参与
- **离线智能**：在网络断开状态下依然能够提供基本的智能服务和数据处理

### 2. 高级交互与界面适应

- **多模态交互**：支持语音、文本、手势、视觉等多种输入方式的无缝融合
- **意图理解与预测**：预测用户可能的下一步操作，提前加载资源或准备响应
- **界面自适应重组**：根据用户行为模式和偏好自动调整UI布局和交互模式
- **情境感知**：根据时间、地点、设备状态等上下文信息调整应用行为

### 3. 数据处理与优化

- **智能数据压缩**：对大规模数据使用向量量化和语义压缩技术，降低传输和存储开销
- **流式处理**：实现类似流处理的数据管道，在数据到达时即开始处理而非等待完整数据
- **增量渲染**：基于重要性优先渲染关键内容，同时在后台处理次要内容
- **自适应缓存策略**：使用预测模型决定何时预加载内容以及缓存什么内容

### 4. 分布式协作能力

- **端到端联邦学习**：多用户客户端共同训练模型而不共享原始数据
- **P2P资源共享**：基于WebRTC实现客户端之间的直接资源和计算能力共享
- **分布式计算任务**：将复杂任务分解并在多个客户端间分配执行
- **协作内容生成**：支持多用户实时协同创作和编辑AI生成内容

### 5. 自我优化与演进

- **自动性能分析**：持续监控并分析应用性能瓶颈，自动调整执行策略
- **自我调试能力**：检测并尝试修复前端代码问题或不兼容性
- **自适应API调用**：根据网络状况、服务响应时间自动调整API调用策略
- **渐进式增强**：随着用户使用时间增长，不断增强功能和性能

### 6. 混合计算范式

- **边缘计算整合**：智能划分计算任务到客户端、CDN边缘节点和云服务器
- **异步计算管道**：使用Web Workers和SharedArrayBuffer实现并行计算
- **计算卸载策略**：根据设备能力和网络状况动态决定本地处理还是远程处理
- **渐进式计算**：先快速给出近似结果，然后在后台继续优化结果精度

### 7. 源码自我感知与编辑能力

- **DOM与源码双向映射**：构建DOM结构与源代码的精确映射关系，使AI能同时理解视觉表现和代码实现
- **代码结构理解**：分析并理解网页的JavaScript、CSS和HTML结构，掌握组件间依赖和数据流
- **受控源码编辑**：通过安全的受控接口执行源码修改，确保变更符合应用架构和安全限制
- **实时编译与测试**：在应用源码修改前，在沙箱环境中进行编译和单元测试验证
- **变更影响分析**：自动分析代码修改对应用其他部分的潜在影响，预测并防止级联错误
- **自动版本控制**：每次代码修改自动生成版本记录，支持回滚和变更比较
- **修改意图说明**：为每次源码变更添加自然语言说明，便于开发者理解AI的修改逻辑

### 8. 动态代码更新与部署

- **热更新机制**：实现无需页面刷新的代码变更应用，类似于React Hot Reload但扩展到整个应用范围
- **增量更新策略**：只重新评估和应用被修改部分的代码，最小化性能影响
- **状态保持更新**：在代码更新过程中保持应用状态不丢失，确保用户体验连续性
- **原子部署**：将相关变更作为一个原子单元应用，确保应用不会处于不一致状态
- **回滚自动化**：检测到更新引起的异常后自动回滚到先前稳定版本
- **多级部署管道**：支持从开发沙箱、预览到生产环境的逐级部署流程
- **A/B测试集成**：能够针对不同用户群体部署不同版本的代码变更，评估效果

### 9. 安全与权限机制

- **代码修改权限分级**：基于影响范围和重要性对代码修改进行分级授权
- **敏感区域保护**：识别并特别保护包含认证、支付等功能的关键代码区域
- **代码审核流程**：重要变更需经过自动静态分析和可选的人工审核
- **沙箱隔离执行**：在隔离环境中预执行修改后的代码评估安全性
- **代码注入防护**：严格校验所有动态生成的代码，防止XSS和其他注入攻击
- **API使用限制**：限制自动生成代码可以访问的API范围，特别是敏感或高权限API
- **数据访问控制**：确保AI修改的代码遵循既定的数据访问权限规则

### 关键技术栈

1. **核心运行时**：WebAssembly + Web Workers + Service Workers
2. **AI能力**：TensorFlow.js / ONNX Runtime Web / WebGPU
3. **高性能数据结构**：基于SharedArrayBuffer的并发数据结构
4. **网络优化**：HTTP/3 + WebTransport + Compression Streams API
5. **存储技术**：IndexedDB + Cache API + 文件系统访问
6. **UI框架**：声明式UI + 虚拟DOM + 高效差异算法
7. **源码处理**：AST解析与操作 + 代码转换工具链 + 静态分析
8. **部署机制**：模块热替换 + 状态管理快照 + 增量构建系统

### 挑战与限制

- **浏览器沙箱限制**：浏览器安全限制可能阻碍某些高级功能的实现
- **设备异构性**：需要适应从低端移动设备到高性能台式机的广泛设备范围
- **电池和资源消耗**：高级AI功能可能导致设备电池快速耗尽和资源占用过高
- **用户隐私考量**：本地AI处理需要平衡功能与隐私保护
- **代码安全风险**：自动代码修改可能引入安全漏洞或不稳定性
- **变更审核需求**：关键系统可能仍需人工审核AI提出的重大变更
- **框架兼容性**：不同前端框架对动态代码更新的支持程度不同

### 实现路径建议

1. **基础设施层**：首先构建代码解析、安全沙箱和热更新基础设施
2. **分析能力层**：开发代码理解和影响分析能力
3. **修改执行层**：实现受控代码编辑和应用能力
4. **安全审核层**：建立代码安全检查和权限控制机制
5. **集成大模型**：通过API集成大模型进行代码生成和分析
6. **渐进式部署**：从辅助开发工具开始，逐步过渡到自主更新能力

这种"左脚踩右脚上天"的AI前端架构将打破传统Web应用的限制，创造出类似原生应用甚至超越原生应用的用户体验，同时保持Web平台的普遍可访问性和即时部署特性。通过赋予AI源码自我感知与编辑能力，它不仅能适应用户需求，还能持续优化自身实现，实现真正的自我进化。 