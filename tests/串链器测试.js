import { 创建串链器, 创建扩展定义 } from '../src/工具箱/forCore/串链器.js';

// 工具函数，用于运行测试并捕获错误
const 运行测试 = (名称, 函数) => {
  try {
    函数();
    console.log(`✓ 测试通过: ${名称}`);
  } catch (错误) {
    console.error(`✗ 测试失败: ${名称}`);
    console.error(`  预期结果: ${错误.预期}`);
    console.error(`  实际结果: ${错误.实际}`);
    if (错误.堆栈) console.error(`  堆栈: ${错误.堆栈}`);
  }
};

// 添加原生断言方法
function 严格相等(实际, 预期) {
  console.log(实际, 预期);
  if (实际 !== 预期) {
    const 错误 = new Error();
    错误.预期 = 预期;
    错误.实际 = 实际;
    throw 错误;
  }
}


// 基础功能测试
console.log('\n=== 串链器基础功能测试 ===');

const 基础测试 = () => {
  // 设置测试环境
  const 设置基础链 = () => {
    const 链 = 创建串链器();

    // 注册基础测试方法
    链.加法((数值, 增量) => 数值 + 增量)
      .乘法((数值, 系数) => 数值 * 系数)
      .平方((数值) => 数值 * 数值)
      .立方((数值) => 数值 * 数值 * 数值)
      .绝对值((数值) => Math.abs(数值))
      .取反((数值) => -数值)
      .输出(数值 => 数值);

    // 添加一些带匹配器的方法
    //匹配器数组越长，越先执行
    //所以这里的处理数字方法，预期会先在处理数字和处理字符串方法之后,没有匹配才会执行默认处理
    链.处理数字((当前值) => 当前值 + 1, (当前值, ...参数) => typeof 当前值 === 'number')
      .处理数字((当前值) => `处理字符串: ${当前值}`, (当前值, ...参数) => typeof 当前值 === 'string')
      .处理数字((当前值) => '默认处理');

    return 链;
  };

  // 基本链式调用
  运行测试('基本链式调用', () => {
    const 链 = 设置基础链();
    const 结果 = 链(5).加法(3).乘法(2).平方().值;
    严格相等(结果, 256);
  });

  // 方法参数传递
  运行测试('方法参数传递', () => {
    const 链 = 设置基础链();
    const 结果 = 链(10).加法(5).乘法(2).加法(30).值;
    严格相等(结果, 60);
  });

  // 终止调用
  运行测试('终止调用', () => {
    const 链 = 设置基础链();
    const 结果 = 链(5).加法(3).值;
    严格相等(结果, 8);
  });

  // 匹配器功能
  运行测试('匹配器功能', () => {
    const 链 = 设置基础链();
    严格相等(链(5).处理数字().值, 6);

    严格相等(链("hello").处理数字().值, "处理字符串: hello");
    严格相等(链(null).处理数字().值, "默认处理");
  });

  // 多次调用保持独立上下文
  运行测试('多次调用保持独立上下文', () => {
    const 链 = 设置基础链();
    const 链1 = 链(5).加法(3);
    const 链2 = 链(10).加法(5);

    严格相等(链1.值, 8);
    严格相等(链2.值, 15);

    const 链1结果 = 链1.乘法(2).值;
    严格相等(链1结果, 16);
    严格相等(链2.值, 15); // 链2不应受链1影响
  });

  // 使用原生对象方法
  运行测试('使用原生对象方法', () => {
    const 链 = 设置基础链();
    const 字符串结果 = 链("hello").toUpperCase().值;
    严格相等(字符串结果, "HELLO");

    const 数组结果 = 链([1, 2, 3]).map(x => x * 2).join('-').值;
    严格相等(数组结果, "2-4-6");
  });
};

基础测试();

// 高级功能测试
console.log('\n=== 串链器高级功能测试 ===');

const 高级功能测试 = () => {
  // 设置测试环境
  const 设置高级链 = () => {
    const 链 = 创建串链器();

    链.加法((数值, 增量) => 数值 + 增量)
      .乘法((数值, 系数) => 数值 * 系数)
      .条件转换((数值, 转换函数) => 转换函数(数值))
      .执行函数((数值, 函数) => 函数(数值));

    return 链;
  };

  // 条件分支
  运行测试('条件分支', () => {
    const 链 = 设置高级链();
    const 结果 = 链(10)
    .分支([
      [x => x > 0, 值 => 链(值).加法(5).值],
      [x => x === 0, 值 => 链(值).加法(10).值],
      [x => x < 0, 值 => 链(值).乘法(-1).加法(5).值]
    ]
    )
      .乘法(2)
      .值;
    console.log(结果, 30);
    严格相等(结果, 30); // (10+5)*2 = 30

    const 负数结果 = 链(-10)
      .分支([
        [x => x > 0, 值 => 链(值).加法(5).值],
        [x => x === 0, 值 => 链(值).加法(10).值],
        [x => x < 0, 值 => 链(值).乘法(-1).加法(5).值]
      ]
      )
      .乘法(2)
      .值;
      console.log(负数结果, 30);

    严格相等(负数结果, 30); // (-10*-1+5)*2 = 30
  });

  // 函数管道
  运行测试('函数管道', () => {
    const 链 = 设置高级链();
    const 加5 = x => x + 5;
    const 乘2 = x => x * 2;
    const 平方 = x => x * x;

    const 结果 = 链(3).条件转换(加5).条件转换(乘2).条件转换(平方).值;
    严格相等(结果, 256); // ((3+5)*2)^2 = 16^2 = 256
  });
};

高级功能测试();

// 扩展系统测试
console.log('\n=== 串链器扩展系统测试 ===');

const 扩展系统测试 = () => {
  // 设置测试环境
  const 设置基础链 = () => {
    const 链 = 创建串链器();

    // 基础方法
    链.加法((数值, 增量) => 数值 + 增量)
      .乘法((数值, 系数) => 数值 * 系数);

    return 链;
  };

  // 安装简单扩展
  运行测试('安装简单扩展', () => {
    const 链 = 设置基础链();
    const 数学扩展 = 创建扩展定义({
      ID: '数学扩展',
      初始化: (扩展管理器, 定义接口) => {
        定义接口
          .平方((数值) => 数值 * 数值)
          .立方((数值) => 数值 * 数值 * 数值);
      }
    });

    链.扩展.安装(数学扩展);

    const 结果 = 链(3).加法(2).平方().立方().值;
    严格相等(结果, 15625); // ((3+2)^2)^3 = 15625
  });

  // 扩展列表获取
  运行测试('扩展列表获取', () => {
    const 链 = 设置基础链();
    const 数学扩展 = 创建扩展定义({
      ID: '数学扩展',
      初始化: (扩展管理器, 定义接口) => {
        定义接口.平方((数值) => 数值 * 数值);
      }
    });

    链.扩展.安装(数学扩展);

    const 扩展列表 = 链.扩展.列表();
    严格相等(Array.isArray(扩展列表), true);
    严格相等(扩展列表.includes('数学扩展'), true);
  });

  // 卸载扩展
  运行测试('卸载扩展', () => {
    const 链 = 设置基础链();
    const 数学扩展 = 创建扩展定义({
      ID: '数学扩展',
      初始化: (扩展管理器, 定义接口) => {
        定义接口.平方((数值) => 数值 * 数值);
      }
    });

    链.扩展.安装(数学扩展);
    严格相等(链.扩展.列表().includes('数学扩展'), true);

    链.扩展.卸载('数学扩展');
    严格相等(!链.扩展.列表().includes('数学扩展'), true);
  });

  // 依赖检查失败
  运行测试('依赖检查失败', () => {
    const 链 = 设置基础链();
    const 高级数学扩展 = 创建扩展定义({
      ID: '高级数学扩展',
      初始化: () => { }
    });

    let 抛出错误 = false;
    try {
      链.扩展.安装(高级数学扩展, { 依赖: '基础数学扩展' });
    } catch (错误) {
      抛出错误 = 错误.message.includes('依赖的扩展');
    }

    严格相等(抛出错误, true);
  });
};

扩展系统测试();

// 边界情况测试
console.log('\n=== 串链器边界情况测试 ===');

const 边界情况测试 = () => {
  // 设置测试环境
  const 设置边界测试链 = () => {
    const 链 = 创建串链器();

    链.处理值((值) => 值 === null ? '空值' : 值 === undefined ? '未定义' : 值)
      .加一((值) => 值 + 1)
      .转字符串((值) => String(值))
      .异步处理((值) => Promise.resolve(值 * 2));

    return 链;
  };

  // 处理null和undefined
  运行测试('处理null和undefined', () => {
    const 链 = 设置边界测试链();
    严格相等(链(null).处理值().值, '空值');
    严格相等(链(undefined).处理值().值, '未定义');
  });

  // 处理数字0
  运行测试('处理数字0', () => {
    const 链 = 设置边界测试链();
    严格相等(链(0).加一().值, 1);
  });

  // 处理空字符串
  运行测试('处理空字符串', () => {
    const 链 = 设置边界测试链();
    严格相等(链('').转字符串().值, '');
  });

  // 处理异步操作
  运行测试('处理异步操作', async () => {
    const 链 = 设置边界测试链();
    const 异步链 = 链(5).异步处理();
    严格相等(异步链 instanceof Promise, true);

    const 结果 = await 异步链;
    严格相等(结果.值, 10);
  });

  // 处理大数据
  运行测试('处理大数据', () => {
    const 链 = 设置边界测试链();
    const 大数组 = Array(10000).fill(1);
    const 结果 = 链(大数组).map(x => x + 1).reduce((a, b) => a + b, 0).值;
    严格相等(结果, 20000);
  });
};

边界情况测试();

console.log('\n所有测试完成!');