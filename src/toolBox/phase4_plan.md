# 工具箱重构阶段5计划

## 概述

阶段5将专注于完成思源笔记特有功能的整合，重点对已经实现的功能进行优化，解决代码冗余问题，并对现有模块进行功能整合与接口规范化。同时，将开展性能优化和文档完善工作。

## 详细计划

### 1. 思源笔记工具函数整合与优化

#### 1.1 整合已实现的模块功能
- 优化`useSiyuanSlash.js`和`useSiyuanDialog.js`之间的功能重叠
- 完善`useSiyuanMenuBuilder.js`和`useSiyuanMenu.js`的接口统一
- 整合`useSiyuanColor.js`中的颜色工具与其他UI功能
- 重构`useSiyuanTab.js`减少冗余代码

#### 1.2 功能完善与扩展
- 为`useSiyuanDialog.js`添加更多对话框模板和样式
- 增强`useSiyuanSlash.js`的命令注册与搜索功能
- 扩展`useSiyuanBlock.js`的块操作功能，增加批量处理能力
- 强化`useSiyuanAsset.js`的资源管理功能，提高处理效率

#### 1.3 接口规范化
- 统一所有思源相关模块的错误处理机制
- 规范化参数命名和返回值格式
- 添加类型定义和参数验证
- 优化异步操作处理流程

### 2. 性能优化

#### 2.1 延迟加载与按需导入优化
- 实现更细粒度的模块拆分
- 优化`toolBoxExports.js`的导出结构
- 实现关键模块的预加载策略
- 减少启动时的资源占用

#### 2.2 缓存策略优化
- 为频繁使用的API结果实现缓存机制
- 添加缓存过期和更新策略
- 实现资源的本地存储与同步更新
- 开发缓存状态监控工具

#### 2.3 批量操作优化
- 改进批量处理的并发控制
- 添加任务队列和中断恢复功能
- 优化大型数据集的处理效率
- 实现操作进度反馈机制

### 3. 文档与示例完善

#### 3.1 API文档更新
- 为所有模块添加完整的JSDoc注释
- 生成标准化的API文档
- 添加参数和返回值详细说明
- 补充错误处理和边界情况说明

#### 3.2 使用示例扩展
- 为每个主要功能创建示例代码
- 添加常见场景的使用指南
- 开发可交互的示例项目
- 编写故障排除文档

#### 3.3 开发者文档完善
- 更新架构设计文档
- 添加贡献指南和代码风格说明
- 完善模块依赖关系图
- 编写扩展开发指南

### 4. 重构与解耦

#### 4.1 目录结构优化
- 调整`forSiyuan`目录结构，按功能域更清晰划分
- 合并功能相似的模块，减少文件数量
- 移除过时或重复的代码
- 规范化文件命名和路径组织

#### 4.2 依赖管理优化
- 减少模块间的循环依赖
- 优化内部依赖关系，实现更好的解耦
- 集中管理外部依赖引用
- 减少全局状态的使用

#### 4.3 兼容层重构
- 优化现有的兼容层实现
- 为过时API添加废弃警告
- 制定API迁移计划和时间表
- 开发迁移辅助工具

## 优先级安排

1. 首先完成思源笔记工具函数的整合与接口规范化
2. 同步进行性能优化工作
3. 进行重构与解耦
4. 最后完善文档与示例

## 预期交付物

1. 优化后的思源笔记工具函数集
2. 性能测试报告和优化结果
3. 完整的API文档和使用示例
4. 重构和解耦后的清晰目录结构

## 预计时间表

- 思源笔记工具函数整合与优化: 2周
- 性能优化: 1周
- 重构与解耦: 1周
- 文档与示例完善: 1周

## 评估指标

1. API接口的一致性和可用性
2. 工具函数的性能和资源占用
3. 代码质量和可维护性
4. 文档完整性和可读性

## 风险与缓解措施

| 风险 | 影响 | 缓解措施 |
|------|------|----------|
| 接口变更影响现有代码 | 功能失效或错误 | 保持兼容层，提供平滑迁移路径 |
| 性能优化引发新问题 | 稳定性下降 | 增加测试覆盖，渐进式部署优化 |
| 重构过程中的代码回归 | 功能损失 | 建立完整的自动化测试，确保功能完整性 |
| 文档更新不及时 | 开发效率降低 | 将文档更新作为重构流程的强制部分 |

## 5. 目录结构整理计划 (来自 AInote)

**目标:** 将 `src/toolBox` 下所有目录和文件严格按照 `base/`, `feature/`, `useAge/` 三层架构进行组织，确保职责清晰和依赖关系正确。

**待处理目录:**

以下顶层目录目前不符合预期的三层结构，需要进行整理：

1.  **`electron/`**:
    *   **分析:** 包含 Electron 平台相关的功能。
    *   **计划:** 分析其具体内容。如果是底层平台 API 封装，迁移至 `base/usePlatform/forElectron/`；如果是特定的 UI 或功能，迁移至 `feature/forElectronFeature/` 或相应的 `feature` 子目录。
    *   **下一步:** 分析 `electron/` 目录内容。
2.  **`useNode/`**:
    *   **分析:** 包含 Node.js 环境相关的功能。
    *   **计划:** 迁移至 `base/usePlatform/forNode/`。
    *   **下一步:** 执行迁移。
3.  **`debug/`**:
    *   **分析:** 包含调试相关的工具。
    *   **计划:** 分析其内容。通用调试工具迁移至 `base/forDebugging/`；与特定功能相关的调试辅助移至对应 `feature/` 或 `useAge/` 目录。
    *   **下一步:** 分析 `debug/` 目录内容。
4.  **`legacy/`**:
    *   **分析:** 存放待重构或废弃的旧代码。
    *   **计划:** 逐一分析内部文件，将其重构并迁移到 `base/`, `feature/`, `useAge/` 的合适位置，或者确认废弃后删除。最终目标是清空并删除 `legacy/` 目录。
    *   **下一步:** 分析 `legacy/` 目录内容。
5.  **`framework/`**:
    *   **分析:** 命名宽泛，可能包含框架集成或通用框架工具。
    *   **计划:** 分析其内容。根据具体功能判断归属：底层框架支持放入 `base/`，特定框架 (如 Vue) 集成放入 `feature/useFramework/` 或 `feature/useVue/`。
    *   **下一步:** 分析 `framework/` 目录内容。
6.  **`web/`**:
    *   **分析:** Web 相关功能。
    *   **计划:** 分析其内容。区分底层 Web API (应在 `base/useBrowser/` 或 `base/forNetwork/`) 和更高级的 Web 特定功能 (可放入 `feature/forWeb/`)。
    *   **下一步:** 分析 `web/` 目录内容。
7.  **`app/`**:
    *   **分析:** 可能包含应用层级的工具或逻辑，与 `useAge/` 定位重叠。
    *   **计划:** 分析其内容，将其功能迁移到 `useAge/` 下对应的场景子目录中。
    *   **下一步:** 分析 `app/` 目录内容。
8.  **`thirdParty/`**:
    *   **分析:** 包含第三方库的封装或直接引用，违反了依赖管理原则。
    *   **计划:** **必须** 将其所有内容按照依赖类型，迁移到 `base/useDeps/` 下相应的封装模块中。完成后删除 `thirdParty/` 目录。
    *   **下一步:** 分析 `thirdParty/` 内容并执行迁移。
9.  **`message/`**:
    *   **分析:** 消息传递或通信相关。
    *   **计划:** 分析其内容。底层通信机制放入 `base/forCommunication/` 或 `base/forEvent/`；特定场景的消息处理放入 `feature/` 或 `useAge/`。
    *   **下一步:** 分析 `message/` 目录内容。

**通用操作:**

*   在所有目标目录（包括新建的）中，将创建或更新 `AInote.md` 和 `README.md` 文件，说明其职责和内容。
*   迁移过程中，遵循"最小改动"原则，优先创建兼容导出，逐步替换引用。

**下一步重点:**

*   完成此计划更新后，将开始逐一**分析**上述标记为需要分析的目录内容，以确定最合适的迁移目标位置，然后再进行实际的文件移动和重构。

## 6. 迁移遗留任务 (来自 AInote / src/utils)

*   **`src/utils/css/`**:
    *   `border.js`
    *   `cssVarGenerator.js`
    *   `inherentValues.js`
    *   `unitedStrings.js`
*   **`src/utils/draw/`**:
    *   着色器文件 (`constants.wgsl`, `colors.wgsl`, `mixer.wgsl`): 迁移至 `src/toolBox/feature/forCanvas/useGPUMixing/`。
    *   `brushes.js`
    *   `index.js`
    *   `brushSampleProcessor.js`
    *   `gpuMix.js`
    *   `simpleDraw/` (目录)
    *   `brushes/` (目录)

## 7. 工具函数迁移计划 (来自 AInote)

**目标:** 将 `source/utils` 等目录下散落的通用工具函数迁移到 `toolBox` 的合适位置。

### 待迁移内容分析

1.  **来自 `source/utils/functionTools.js`**
    *   **内容:** 函数式编程工具：`顺序组合函数`, `管道函数`, `柯里化`, `等待参数达到长度后执行`, `组合函数`等。
    *   **迁移目标:** `src/toolBox/base/forChain/`，作为基础层的函数链功能。
    *   **优先级:** 高 (基础工具)。

2.  **来自 `source/utils/functionAndClass/performanceRun.js`**
    *   **内容:** 性能监测包装器：`withPerformanceLogging`。
    *   **迁移目标:** `src/toolBox/base/useEcma/performance.js` 或创建新的 `base/forDebugging/` 相关目录。
    *   **优先级:** 高 (用于优化和调试)。

3.  **来自 `source/utils/vector/similarity.js`**
    *   **内容:** 向量计算工具：`计算归一化向量余弦相似度`, `计算余弦相似度`, `计算欧氏距离相似度`, `计算Levenshtein距离`。
    *   **迁移目标:** `src/toolBox/feature/forVectorEmbedding/similarity.js` (部分可能已存在于 `base/forMath/`)。
    *   **优先级:** 中 (特定领域工具)。

### 迁移步骤

1.  **代码分析与清理:** 检查代码质量、依赖，移除冗余，标准化接口。
2.  **功能迁移:** 遵循三层架构，创建目录和文件，优化实现。
3.  **接口统一:** 提供中英文命名，统一错误处理，完善文档。
4.  **测试与验证:** 添加单元测试，验证功能一致性，检查性能。
5.  **更新引用:** 使用兼容层或别名，逐步更新调用代码，记录废弃 API。

## 8. 全局依赖引用规范化计划

**目标:** 确保项目中所有对外部依赖（npm 包、内置模块、静态资源等）的引用都通过 `src/toolBox/base/deps/` 目录下的转发模块进行，实现依赖来源的统一管理和解耦。

**背景:** 通过 `scripts/scan-direct-dependencies.js` 脚本扫描，发现大量不符合规范的直接依赖引用。

**执行步骤:**

1.  **运行扫描脚本:** 定期（或在需要时）运行 `node scripts/scan-direct-dependencies.js | cat` 获取最新的直接依赖引用列表。
2.  **分析结果:** 对脚本输出进行排序，优先处理被直接引用次数最少的依赖项。
3.  **逐个处理依赖项:**
    *   **定位引用:** 找到所有直接引用该依赖的文件。
    *   **创建/确认转发模块:** 在 `src/toolBox/base/deps/` 目录下为该依赖创建（如果不存在）或确认已存在对应的转发模块（如 `src/toolBox/base/deps/npm/lodash.js` 或 `src/toolBox/base/deps/node/fs.js`）。确保转发模块导出了所有需要被引用的 API。
    *   **修改引用:** 将步骤 a 中找到的文件里的直接引用修改为通过对应的 `deps/` 转发模块导入。
    *   **更新文档:** 更新涉及到的文件所在目录的 `AInote.md`，记录依赖引用的修改。
4.  **持续迭代:** 重复步骤 1-3，直到所有不合规的直接引用都被修复。

**注意事项:**

*   对于某些特殊情况（如构建脚本、配置文件等），如果确实无法或不适合通过 `deps/` 转发，需要特殊说明并记录在 `GUIDELINES.md` 的例外情况中。
*   在创建新的转发模块时，要注意按依赖类型（npm, node, static 等）组织在 `deps/` 的子目录下。 