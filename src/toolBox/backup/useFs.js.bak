/**
 * 文件系统工具函数集
 * 注意: 此文件仅用于向后兼容，新代码请直接使用useFs文件夹中的模块
 */

// 从分离的模块中重新导出所有功能
export * from './useFs/index.js';

/**
 * 文件系统工具函数集
 * 函数命名遵循前缀式语义化命名法
 * 单参数函数为纯函数，双参数函数中第一个是context，第二个是options
 */
const fs = require('fs').promises;
const path = require('path');

/**
 * 从上下文获取文件状态信息
 * @param {Object} context - 包含文件路径的上下文
 * @returns {Promise<Object>} 包含文件状态的对象
 */
const useFileStatus = async (context) => {
    const { filePath } = context;
    
    if (!filePath) {
        throw new Error('必须提供文件路径(filePath)');
    }
    
    // 创建新对象，不修改输入参数
    const result = {
        normalizedPath: path.normalize(filePath),
        fileExists: true,
        fileStats: null,
        fs,
        path
    };
    
    try {
        result.fileStats = await fs.stat(result.normalizedPath);
    } catch (statError) {
        if (statError.code === 'ENOENT') {
            result.fileExists = false;
        } else {
            throw statError;
        }
    }
    
    return result;
};

/**
 * 创建文件（如需要）
 * @param {Object} context - 上下文对象
 * @param {Object} options - 操作选项
 * @returns {Promise<Object>} 更新后的上下文
 */
const withFileCreation = async (context, options) => {
    // 解构上下文，允许修改context
    const { normalizedPath, fileExists, fs, path } = context;
    // 解构选项，确保不修改
    const { 
        createIfNotExists = false, 
        defaultContent = '',
        skipIfNotExists = false,
        logProcess = false
    } = options;
    
    if (!fileExists && createIfNotExists) {
        // 确保目录存在
        await fs.mkdir(path.dirname(normalizedPath), { recursive: true });
        
        // 创建文件
        await fs.writeFile(normalizedPath, defaultContent);
        
        context.fileStats = await fs.stat(normalizedPath);
        context.fileExists = true;
        
        if (logProcess) console.log(`已创建文件: ${normalizedPath}`);
    } else if (!fileExists && !skipIfNotExists) {
        throw new Error(`文件不存在: ${normalizedPath}`);
    }
    
    return context;
};

/**
 * 使用超时机制执行Promise
 * @param {Promise} promise - 要执行的Promise
 * @param {Object} options - 超时配置
 * @returns {Promise<any>} Promise执行结果
 */
const withTimeout = (promise, options) => {
    const { timeout = 0, errorMessage = '操作超时' } = options;
    
    if (timeout <= 0) return promise;
    
    let timeoutId;
    const timeoutPromise = new Promise((_, reject) => {
        timeoutId = setTimeout(() => {
            reject(new Error(`${errorMessage}: ${timeout}ms`));
        }, timeout);
    });
    
    return Promise.race([promise, timeoutPromise])
        .finally(() => {
            if (timeoutId) clearTimeout(timeoutId);
        });
};

/**
 * 处理执行过程中的错误
 * @param {Object} context - 上下文对象
 * @param {Object} options - 错误处理选项
 * @returns {Promise<any>} 错误处理结果或抛出错误
 */
const withErrorHandling = (context, options) => {
    const { error, logProcess = false, errorHandler = null } = options;
    
    // 直接修改context
    context.error = error;
    context.errorTime = new Date();
    context.errorMessage = error.message;
    context.errorStack = error.stack;
    
    if (logProcess) {
        console.error(`执行错误: ${error.message}`);
    }
    
    if (errorHandler) {
        return Promise.resolve(errorHandler(context));
    }
    
    throw error;
};

/**
 * 检查文件并按条件执行相关操作
 * @param {Object} context - 包含文件路径和所需操作的上下文对象
 * @param {Object} options - 操作选项
 * @returns {Promise<any>} 执行结果或false
 */
const useFileExecution = async (context, options = {}) => {
    try {
        // 获取文件状态并合并到context
        const fileStatus = await useFileStatus(context);
        Object.assign(context, fileStatus);
        context.startTime = Date.now();
        
        // 处理文件不存在情况
        await withFileCreation(context, options);
        
        // 执行条件判断
        const conditionPromise = Promise.resolve(options.condition?.(context) ?? true);
        const conditionResult = await withTimeout(
            conditionPromise, 
            { 
                timeout: options.timeout || 0, 
                errorMessage: '条件判断超时' 
            }
        );
        
        if (options.logProcess) {
            console.log(`条件判断结果: ${conditionResult}`);
        }
        
        // 条件通过则执行操作
        if (conditionResult) {
            const executorPromise = Promise.resolve(options.executor?.(context) ?? undefined);
            const result = await withTimeout(
                executorPromise, 
                { 
                    timeout: options.timeout || 0, 
                    errorMessage: '执行操作超时' 
                }
            );
            
            if (options.logProcess) {
                const endTime = Date.now();
                console.log(`执行完成，耗时: ${endTime - context.startTime}ms`);
            }
            
            return result;
        }
        
        return false;
    } catch (error) {
        return withErrorHandling(context, {
            error,
            logProcess: options.logProcess,
            errorHandler: options.errorHandler
        });
    }
};

// 导出模块功能，使用命名导出而非默认导出
export {
    useFileStatus,
    withFileCreation,
    withTimeout,
    withErrorHandling,
    useFileExecution
};

