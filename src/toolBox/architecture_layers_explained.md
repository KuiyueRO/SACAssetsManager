# 工具箱架构分层详解：Base vs. Feature vs. Domain

本文档详细解释 `toolBox` 采用的三层架构 (`base`, `feature`, `domain`) 中各层的职责定位、关键区别和划分原则。

## 三层架构概述

1.  **`base/` (基础层):**
    *   **定位:** 提供最核心、通用、稳定的构建块。
    *   **关注点:** 与环境、语言特性、基础设施相关的**底层能力**封装。
    *   **组织方式:** 按**技术基础或底层概念**分类（如 `lang`, `platform`, `io`, `core`）。
    *   **依赖:** **禁止**依赖项目其他模块 (`feature`, `domain`)，保持高度独立性。

2.  **`feature/` (特性层):**
    *   **定位:** 提供基于 `base` 构建的、具有**特定技术能力或独立功能**的模块。
    *   **关注点:** 封装**可重用的、相对独立的技术功能**（"能力"）。它关注"怎么做"的技术细节。
    *   **组织方式:** 按**独立功能或能力领域**分类（如 `imageProcessing`, `stateManagement`, `textAnalysis`）。
    *   **依赖:** 只依赖 `base` 层。

3.  **`domain/` (领域层 / useAge):**
    *   **定位:** 面向具体应用场景或任务的解决方案。
    *   **关注点:** **利用** `base` 和 `feature` 提供的能力，**组合、编排**它们来解决**特定领域或任务**的问题（"方案"或"工作流"）。它关注"为什么"以及"在哪个具体场景下"使用这些能力。
    *   **组织方式:** 按**应用领域或任务类型**分类（如 `siyuanIntegration`, `fileBatchProcessing`, `eagleAdapter`）。
    *   **依赖:** 可依赖 `base` 和 `feature` 层。

## 三层分类法：关键区别与划分原则

正确区分 `base`, `feature`, `domain` 三层是保持工具箱通用性、稳定性和可维护性的核心。关键在于判断代码是提供**底层基础**、**通用技术能力**还是实现**特定领域的应用方案**。

**核心区别：**

| 层面      | 关注点                   | 目标             | 特征                                         | 依赖特定应用逻辑/API? | 依赖范围         |
| :-------- | :----------------------- | :--------------- | :------------------------------------------- | :-------------------- | :--------------- |
| `base/`    | **底层基础 (Foundation)** | 构建稳固通用基石 | 极简依赖；高度抽象；环境/语言核心封装       | **绝对禁止**          | **无**           |
| `feature/` | **技术能力 (Capability)** | 构建通用技术积木 | 不含特定业务逻辑；技术性配置；可跨项目复用 | **禁止**              | `base`           |
| `domain/`  | **领域方案 (Solution)**   | 解决特定场景问题 | 含业务规则/流程；编排能力；与特定应用耦合   | **允许**              | `base`, `feature` |

**判断标准（问自己）：**

1.  **依赖性 & 稳定性:** 这段代码是否依赖 `feature` 或 `domain` 层？它是否应该绝对稳定，不随业务变化而轻易改动？
    *   **符合 ->** 必须是 `base`。

2.  **通用性测试:** 这段代码离开了我当前的应用场景（如思源笔记），还能直接用在别的、完全不同的项目里吗？
    *   **能 (且不依赖 feature/domain):** 倾向于 `base`。
    *   **能 (但可能依赖 base):** 倾向于 `feature`。
    *   **不能/需大改:** 倾向于 `domain`。

3.  **领域特定性测试:** 这段代码是否包含了只有当前应用（或这类任务）才关心的逻辑、规则或术语？ (例如："块ID"、"笔记本"、"双链语法 `((...))`"?)
    *   **是:** 倾向于 `domain`。
    *   **否 (且通用):** 倾向于 `feature` 或 `base` (参考第1, 2点判断)。

4.  **目的测试:** 这段代码是提供一个**底层基础动作**（如原始网络请求、基本类型判断）、一个**通用的"技术动作"**（如压缩图片、解析 JSON），还是在**"编排"**多个动作来完成一个特定的**"业务目标"**（如生成用户头像、处理思源块链接分析）？
    *   **底层基础动作:** 倾向于 `base`。
    *   **通用技术动作:** 倾向于 `feature`。
    *   **业务目标/工作流:** 倾向于 `domain`。

**示例（扩展）：**

| 功能描述                             | 放在哪里?   | 理由                                                                   |
| :----------------------------------- | :---------- | :--------------------------------------------------------------------- |
| 基础类型检查 `isString(val)`           | `base/`     | 核心语言基础，无依赖，绝对通用和稳定。                                   |
| 封装 `fetch` 的 `request(url, options)` | `base/`     | 底层网络能力封装，应尽量稳定通用。                                       |
| 图片缩放函数 `resizeImage(blob, size)` | `feature/`  | 通用技术能力，依赖 `base` (可能需要 ArrayBuffer 操作)，不关心图片用途。 |
| Markdown 解析器 `parseMarkdown(text)` | `feature/`  | 通用文本解析能力。                                                       |
| Vue 组件加载器 `loadVueComponent(path)`| `feature/`  | 通用 UI 框架集成能力。                                                  |
| 创建思源缩略图 `createSiyuanThumbnail(blob)` | `domain/`   | 包含思源特定尺寸要求，调用思源 API 保存，与思源应用场景耦合。         |
| 分析思源链接 `analyzeSiyuanLinks(md)` | `domain/`   | 查找思源特定语法 `((...))`，与思源笔记领域耦合。                          |
| 显示思源设置对话框 `showSiyuanSettings()` | `domain/`   | 加载为思源定制的 UI，处理思源特定配置逻辑。                                |

**演进与调整：**

分界线有时会模糊。随着项目演进，代码可能需要在不同层级间移动：
*   `feature` -> `domain`: 当通用能力被深度定制，包含过多领域逻辑时。
*   `domain` -> `feature`: 当领域方案中的某部分被发现具有跨场景通用性时。
*   `feature` -> `base`: 当某个特性被证明是更底层、更稳定、更通用的基础时。
*   `base` -> `feature`: （**应极力避免**）如果发现基础层代码实际上依赖了更复杂的功能或不够稳定。

**重要原则：在进行任何 `toolBox` 内的代码结构调整（如文件移动、功能拆分/合并、目录重命名等）之前和之后，*必须* 重新审视本文档中关于 Base, Feature 与 Domain 的划分原则，并根据调整内容更新本文档（特别是示例部分），以确保划分的准确性和一致性始终得到维护。**

保持对这种划分的持续关注和适时调整，是维护一个健康、可扩展工具箱的关键。 