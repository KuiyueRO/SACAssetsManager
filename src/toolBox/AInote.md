# 这个区块的内容来自开发者,禁止AI未经允许修改

现在扫描所有utils等类似命名的文件夹,尝试进行重构

注意我们需要集中思源笔记的环境依赖,可以使用useSiyuan进行集中

由于一些原因项目中零散分布有一些工具文件,你也需要重构这些文件

对于外部依赖,当你发现一个node_modules中的依赖可能可以使用static中使用esm形式打包成静态文件时,你应该提出建议(但是不要修改,这一部分暂时由开发者处理)

注意项目中的**每一个**文件夹你都可以创建readme和AInote

有关重构的最终目标你可以查看项目根目录的index new.js

**已经完成的重构之后应该有一个倒数计数,每次计数为零时视为完成了一个阶段性重构,此时你应该总结当前的任务进度到history.md,不要让太多的细节干扰这个文件的框架**

**阶段计数是一个倒数进度,每次任务计划完成后需要减一,当减至零时表示完成一个阶段,此时应总结进度到history.md并重置计数**

**详细的历史记录应该只出现在history.md中,AInote.md只需要计数和简单提示,这个文件主要记录的是重构心得和要求而不是历史详情**

**先停止不断扩充工具箱,开始检查功能代码的实现**

# 工具箱重构笔记

## 工具箱结构概览

工具箱采用三层分类模块化设计，按功能域组织为不同子目录:

```
src/toolBox/
├── base/           - 基础工具函数
│   ├── useEcma/    - ECMA标准功能封装
│   │   ├── forFile/     - 文件操作相关工具
│   │   ├── forMath/     - 数学计算工具
│   │   ├── forString/   - 字符串处理工具 ✅
│   │   ├── textTools.js - 文本处理工具 ✅
│   │   └── ...
│   ├── forNetwork/  - 网络相关工具
│   │   ├── forFetch/     - fetch工具 ✅
│   │   ├── forPort/      - 端口工具 ✅
│   │   └── ...
│   ├── forEvent/    - 事件处理工具
│   ├── forMime/     - MIME类型处理
│   ├── forCore/     - 核心串链器工具
│   ├── forUI/       - 通用UI组件工具
│   ├── usePolyfills/ - 平台兼容性工具
│   │   ├── uaAnalysis.js - UA分析工具 ✅
│   │   └── ...
│   ├── useDeps/    - 依赖管理工具
│   │   ├── pinyinTools.js - 拼音工具 ✅
│   │   └── ...
│   └── ...
├── feature/        - 特定功能工具
│   ├── useImage/   - 图像处理工具
│   ├── useVue/     - Vue框架工具
│   ├── forFileSystem/ - 文件系统工具
│   └── ...
├── useAge/         - 使用场景相关工具
│   ├── forFileManage/    - 文件管理工具
│   ├── forSiyuan/        - 思源特定功能工具
│   │   ├── useSiyuanMenu.js    - 思源菜单工具 ✅
│   │   ├── useSiyuanDialog.js  - 思源对话框工具 ✅
│   │   ├── useSiyuanSystem.js  - 思源系统API ✅
│   │   └── ...
│   ├── useSiyuan.js      - 思源环境依赖集中管理 ✅
│   └── ...
├── toolBoxExports.js  - 统一导出接口
└── README.md       - 工具箱说明
```

## 已完成的重构(建议不要列举太多,隔一段时间总结一下,列出最近的动作就可以了)

阶段计数:3

当前正在进行重构工作：
- 开始阶段5：专注于思源笔记工具函数的整合与优化，解决模块间功能重叠问题
- 优化useSiyuanSlash、useSiyuanDialog、useSiyuanMenu等模块的接口规范化
- 对冗余代码进行清理，提高代码质量和性能表现
- 完善文档和示例，确保API的一致性和可用性

详细历史记录请查看src/toolBox/history.md

## 重构原则

1. **最小改动**:
   - 创建兼容层以保持现有代码可用
   - 保留原函数名导出，添加中文命名版本

2. **函数式风格**:
   - 尽可能使用纯函数
   - 避免使用类，除非必要
   - 减少嵌套和副作用

3. **命名规范**:
   - 避免无语义的文件名(index.js, main.js)
   - 优先使用中文命名函数
   - 文件名应反映功能

4. **模块化设计**:
   - 按功能域组织工具
   - 相关功能放在同一目录
   - 文件过长时及时拆分

5. **依赖管理规范**:
   - useDeps 目录专门用于处理所有外部模块引用
   - 原则上任何外部模块不能被除了 useDeps 以外的文件直接引用
   - 需要使用外部模块的工具应当通过 useDeps 提供的封装接口进行调用
   - 所有外部依赖应在 useDeps 中进行集中管理和版本控制

## 外部依赖管理原则 (`useDeps`)

**核心原则:** 项目的所有外部依赖（来自 `node_modules` 或 `static`）**必须**通过 [`./base/useDeps`](./base/useDeps) 目录进行统一引入和封装。其他任何模块（包括 `feature` 和 `useAge`）**禁止**直接引入外部依赖。

**目标:**
*   集中管理依赖版本。
*   提供稳定的内部接口，隔离外部变化。
*   简化依赖追踪和维护。

**详情参见:**
*   [`base` 目录 AInote.md 中关于依赖管理的说明](./base/AInote.md#依赖管理)

## 后续重构计划

1. **整合与优化已实现功能**:
   - 解决`useSiyuanSlash.js`和`useSiyuanDialog.js`之间的功能重叠
   - 统一`useSiyuanMenu.js`和相关菜单构建工具的接口
   - 优化`useSiyuanBlock.js`的块操作功能，增强批量处理能力
   - 完善`useSiyuanAsset.js`的资源管理功能

2. **性能优化**:
   - 实现更高效的延迟加载和按需导入策略
   - 为频繁调用的API添加缓存机制
   - 优化批量操作的并发处理
   - 减少启动时的资源占用

3. **目录结构优化**:
   - 调整`forSiyuan`目录结构，按功能更清晰划分
   - 合并功能相似的模块，减少文件数量
   - 移除过时或冗余的代码
   - 规范化文件命名和路径组织

## 注意事项

1. 所有重构应遵循"兼容、增强、替换"的三步走策略:
   - 先建立兼容层保证向后兼容
   - 在新位置增强功能
   - 最后逐步替换旧引用

2. 文件重构应该遵循:
   - 一次只处理少量文件
   - 每次改动应该可测试
   - 保留导入/导出兼容性

3. 代码规范:
   - 文件应尽可能精简，专注于单一职责
   - 优先使用命名导出而非默认导出
   - 同时提供中英文函数命名

## 已完成重构文件的增强

1. **文档增强**:
   - 所有重构文件都添加了完整的JSDoc注释
   - 为所有新文件添加了README.md说明文档

2. **API增强**:
   - 为所有函数添加了中英文双命名支持
   - 优化了函数参数和返回值的类型

3. **兼容性增强**:
   - 为所有已迁移文件创建了兼容层
   - 在原始位置添加了导入/重导出
   - 设置了弃用警告以指导开发者

## 最近完成的重构工作

参见src/toolBox/history.md中的历史记录

## 阶段5重构计划摘要

阶段5将专注于：
1. 思源笔记工具函数的整合与优化，解决模块间功能重叠
2. 性能优化，包括延迟加载、缓存策略和批量操作优化
3. 重构与解耦，优化目录结构和依赖关系
4. 完善文档与示例，提高API的一致性和可用性

详细计划请参考src/toolBox/phase4_plan.md (已更新为阶段5计划)

## 前缀命名规范说明

工具箱中使用的前缀具有明确的语义区分，这些前缀不是随意选择的，而是反映了工具函数的功能定位和使用场景：

1. **for前缀**：针对特定目标领域的工具函数
   - 表示该工具专为某个特定领域或功能设计
   - 例如：`forEvent`（事件处理）、`forMime`（MIME类型处理）、`forNetwork`（网络请求）

2. **use前缀**：基于特定技术或环境实现的工具函数
   - 表示该工具基于某种技术栈或环境API构建
   - 例如：`useEcma`（基于ECMAScript标准）、`useVue`（基于Vue框架）、`useBrowser`（使用浏览器API）

3. **from前缀**：数据源或转换工具
   - 表示从某种数据源获取或转换数据
   - 例如：从Blob创建图像、从SVG创建图像等函数

4. **with前缀**：表示与特定资源结合使用的工具
   - 表示该工具需要与某种资源配合使用
   - 通常用于增强或修饰某个操作

### 嵌套目录的命名规范

当出现嵌套目录时（如 `useEcma/forString/`），应理解为：
- 外层目录（useEcma）表示技术基础
- 内层目录（forString）表示针对的具体目标

### 统一和调整计划

在后续重构中，需要特别注意：
1. 严格遵循前缀语义，不要混用
2. 发现命名不符合规范的目录或文件应进行调整
3. 消除功能重复的模块，遵循前缀规范重新组织

现有的一些问题需要解决：
- `forMime` 和 `useMime` 功能重叠，应明确区分或合并
- `base/forUI` 和 `feature/useUI` 功能可能重叠，需要明确职责
- `useAge/forImageAndCanvas` 与 `feature/useImage` 功能可能重叠

## Static文件夹依赖分析

经过对`static`文件夹的扫描，发现有多种依赖已经以ESM形式存在，可以通过`useDeps`模块进行更充分的封装和利用。以下是主要依赖分类和优化建议：

### 已发现的依赖类别

1. **网络与MIME相关**:
   - accepts.js, type-is.js, content-type.js, content-disposition.js, cache-content-type.js
   - mimeDb.js

2. **数据处理与实用工具**:
   - dayjs.js (及dayjsPlugins/)
   - pinyin.js
   - uuid.mjs
   - buffer.mjs
   - rbush.js
   - mmcq.js (颜色量化)

3. **视觉与UI相关**:
   - vue.esm-browser.js
   - konva.js, vue-konva.mjs
   - pickr-esm2022.js (颜色选择器)
   - dom-to-image.mjs

4. **协作与同步工具**:
   - yjs.js, y-websocket.js, y-webrtc.js, y-indexeddb.js
   - @syncedstore/

5. **多媒体处理**:
   - mp4-muxer.mjs, webm-muxer.mjs
   - opencv.js

6. **语言与解析**:
   - jieba_rs_wasm.js (中文分词)
   - @babel/, @babel_parser.js

7. **AI与机器学习**:
   - tf.min.js
   - @huggingface/

### 优化建议

根据工具箱重构原则，可以在`base/useDeps`目录下创建以下封装模块：

1. **forMimeType**：
   - 封装mimeDb.js和content-type.js等MIME相关依赖
   - 提供统一的MIME类型判断和处理接口

2. **forDateManagement**：
   - 封装dayjs和相关插件
   - 提供日期格式化、解析和操作功能

3. **forUUID**：
   - 封装uuid.mjs
   - 提供UUID生成和解析功能

4. **forPinyin**：
   - 检查现有的pinyinTools.js是否已充分利用static/pinyin.js
   - 可能需要增强拼音处理功能

5. **forUI/useVue**：
   - 封装vue.esm-browser.js的使用
   - 提供Vue组件加载和管理工具

6. **forVisualProcessing**：
   - 封装konva.js, pickr-esm2022.js等
   - 提供画布和颜色处理工具

7. **forCollaboration**：
   - 封装yjs和syncedstore相关库
   - 提供实时协作功能接口

8. **forMedia**：
   - 封装媒体相关工具(mp4-muxer, webm-muxer)
   - 提供统一的媒体处理接口

9. **forAI**：
   - 封装AI工具(@huggingface, tf.min.js)
   - 提供简易的AI功能接口

### 实施优先级

1. 优先封装已有直接引用但未通过useDeps管理的依赖
2. 优先处理核心功能使用的依赖(MIME, 日期, UI等)
3. 为复杂依赖创建简化的接口，降低使用门槛

### 注意事项

1. 封装时保持API稳定，提供中英文双命名
2. 避免将所有依赖捆绑导出，按需加载更为高效
3. 为每个依赖模块创建清晰的文档和使用示例
4. 处理版本冲突，确保使用正确的ESM版本

通过系统性地封装static目录下的依赖，可以提高代码可维护性，减少重复引用，并确保依赖的一致性和可控性。

# 这个区段由开发者编写,未经允许禁止AI修改
<开发者将会在这里提出要求,AI需要判断并满足这些要求>

基于对原有代码的理解，toolBox是一个经过深思熟虑的三层架构设计，旨在提供高度解耦、可重用和性能优化的工具函数库。

关键是保持每一层的职责清晰，确保依赖方向自下而上，避免循环引用。

# ToolBox - 工具箱模块

## 概述

工具箱(`toolBox`)模块是插件的核心基础设施，提供了一套高度模块化、可重用的工具函数集合。采用三层架构设计，确保功能的分离和依赖的清晰管理。

## 架构设计

### 三层架构

1. **基础层 (`base/`)**
   - 提供与环境、语言特性、基础设施相关的工具
   - 不依赖项目其他模块，保持高度独立性
   - 专注于底层能力的封装

2. **特性层 (`feature/`)**
   - 基于基础层构建的功能性工具
   - 解决特定领域问题的工具集
   - 可依赖基础层，但不应依赖应用层

3. **应用层 (`useAge/`)**
   - 面向具体应用场景的工具函数
   - 集成基础层和特性层能力，提供业务级解决方案
   - 可以依赖基础层和特性层

### 依赖规则

- 严格遵循自下而上的依赖原则:
  - `base` 不依赖任何其他模块
  - `feature` 只依赖 `base`
  - `useAge` 可依赖 `base` 和 `feature`

- 禁止循环依赖:
  - 同一层内的模块之间尽量避免互相依赖
  - 必要时通过依赖注入或事件机制解耦

### 导出机制

采用统一的模块导出机制，每一层有自己的导出文件:
- `baseExports.js`
- `featureExports.js`
- `useAgeExports.js`

顶层导出通过 `toolBoxExports.js` 聚合三层导出。

## 基础层详细结构

基础层(`base/`)主要包含以下核心模块:

1. **环境与平台 (`useEnv/`)**
   - 环境检测与适配
   - 平台特性检查
   - 运行时环境管理

2. **ECMA标准功能 (`useEcma/`)**
   - JavaScript语言特性增强
   - 标准函数增强与降级兼容
   - 函数式编程工具

3. **浏览器能力 (`useBrowser/`)**
   - DOM操作工具
   - BOM功能封装
   - 浏览器API适配

4. **网络功能 (`forNetWork/`)**
   - HTTP请求工具
   - 网络状态监测
   - WebSocket封装
   - 端口管理工具

5. **路径处理 (`usePath/`)**
   - 路径解析与构建
   - URL处理
   - 路径安全检查

6. **工具链 (`forChain/`)**
   - 函数组合工具
   - 管道处理函数
   - 链式调用支持

## 特性层详细结构

特性层(`feature/`)包含以下主要模块:

1. **Vue集成 (`useVue/`)**
   - Vue组件动态加载
   - Vue实例创建与管理
   - 自定义组件工具

2. **图像处理 (`useImage/`)**
   - 图像加载与优化
   - 图像转换工具
   - 图像分析功能

3. **面板绑定 (`panelBinding/`)**
   - 界面面板创建工具
   - 事件与数据绑定
   - 面板状态管理

4. **向量与嵌入 (`forVectorEmbedding/`)**
   - 向量计算工具
   - 嵌入模型接口
   - 相似度计算工具

## 应用层详细结构

应用层(`useAge/`)主要模块:

1. **思源笔记集成 (`forSiyuan/`)**
   - 思源API封装
   - 笔记本管理工具
   - 思源特性适配

2. **生态系统集成**
   - Eagle素材库集成 (`forEagle/`)
   - RSS处理工具 (`useRSS/`)
   - NPM集成工具 (`forNpm/`)

3. **文件管理 (`forFileManage/`)**
   - 文件操作工具
   - 目录管理功能
   - 文件系统集成

## 性能优化策略

工具箱模块采用以下性能优化策略:

1. **延迟加载**
   - 非核心功能采用动态导入
   - 按需加载减少初始加载时间

2. **函数优化**
   - 使用记忆化提高重复调用性能
   - 批处理机制减少频繁操作开销

3. **资源管理**
   - 适当缓存避免重复计算
   - 资源池管理重用对象

## 测试与文档

1. **单元测试**
   - 每个工具函数应有对应的单元测试
   - 测试覆盖率目标>90%

2. **文档生成**
   - 使用JSDoc注释生成API文档
   - 提供使用示例和最佳实践

## 工具函数迁移计划

发现source目录下存在多处工具函数需要迁移到toolBox中，特别是source/utils下的函数。

### 待迁移内容分析

1. **来自source/utils/functionTools.js**
   - 函数式编程工具：`顺序组合函数`, `管道函数`, `柯里化`, `等待参数达到长度后执行`, `组合函数`等
   - 迁移目标：`src/toolBox/base/forChain/`，作为基础层的函数链功能

2. **来自source/utils/functionAndClass/performanceRun.js**
   - 性能监测包装器：`withPerformanceLogging`
   - 迁移目标：`src/toolBox/base/useEcma/performance.js`或创建新的性能监测目录

3. **来自source/utils/vector/similarity.js**
   - 向量计算工具：`计算归一化向量余弦相似度`, `计算余弦相似度`, `计算欧氏距离相似度`, `计算Levenshtein距离`
   - 迁移目标：`src/toolBox/feature/forVectorEmbedding/similarity.js`

### 迁移优先级

1. **高优先级**
   - 基础函数式工具 (functionTools.js)：这些是构建其他功能的基础
   - 性能监测工具 (performanceRun.js)：用于优化其他工具函数

2. **中优先级**
   - 向量计算工具 (similarity.js)：在AI特性中使用但不是最基础的组件

### 迁移步骤

1. **代码分析与清理**
   - 检查现有代码质量和依赖关系
   - 删除废弃或多余代码
   - 标准化函数签名和返回值

2. **功能迁移**
   - 遵循三层架构划分功能
   - 创建适当的文件和目录结构
   - 保留原有功能的同时优化实现

3. **接口统一**
   - 提供一致的中英文命名
   - 统一错误处理机制
   - 完善函数文档

4. **测试与验证**
   - 为迁移的功能添加单元测试
   - 验证与原有功能的一致性
   - 检查性能差异

5. **更新引用**
   - 通过导出别名保持向后兼容
   - 渐进式更新调用代码
   - 记录废弃的API并设置迁移计划

## 历史记录与更新日志

### 2023-12-15 更新
- 优化了useVue组件加载机制
- 添加了forSiyuan的API封装
- 完善了工具箱导出结构

### 2023-10-20 更新
- 实现了三层架构基本框架
- 添加了核心工具函数
- 建立了模块间依赖规则


