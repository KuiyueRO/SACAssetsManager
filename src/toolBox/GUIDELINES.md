# ToolBox 开发与重构指南

本文档旨在规范 `src/toolBox` 目录下的代码开发、重构和维护活动，确保工具箱的清晰性、可维护性和可扩展性。

## 核心架构

工具箱采用三层架构，各层职责明确：

- **`base/`**: 存放最核心、通用的基础工具，按**技术或底层概念**组织。
- **`feature/`**: 存放基于`base`构建的、具有**特定技术能力或独立功能**的模块。
- **`useAge/`** (`domains/`, `tasks/`, `applications/`): **严格按照应用领域或任务类型**组织，解决具体场景问题。

详细的分层职责说明，特别是 `feature` 与 `domain` 的划分原则，请参阅：[./architecture_layers_explained.md](./architecture_layers_explained.md)

## 重构原则

1.  **最小改动**:
    *   创建兼容层以保持现有代码可用。
    *   保留原函数名导出，添加中文命名版本。
2.  **函数式风格** & **纯函数优先**:
    *   尽可能使用纯函数设计。
    *   避免副作用和状态依赖。
    *   确保函数输出只依赖输入。
    *   避免使用类，除非必要。
    *   减少嵌套。
3.  **单一职责**:
    *   每个函数专注于单一任务。
    *   避免功能过于复杂。
    *   促进代码复用。
4.  **合理抽象**:
    *   提供适当抽象级别。
    *   封装复杂实现细节。
    *   提供简洁清晰的接口。
5.  **命名规范**:
    *   **核心哲学 (最高优先级):** 所有导出函数（包括中英文命名）**必须**追求"流畅优美的文式编程 (Literate Programming) 风格"。命名应自然融入代码叙述，使其读起来像清晰的文章。此要求必须在**每个子文件夹**的 `README/AInote` 中再次强调。
    *   **基本原则:** 遵循项目根目录定义的 [**编码风格指南**](../../CODING_STYLE.md#命名规范-naming-conventions)，特别是其中的函数前缀规则。
    *   **文件名:** 在 `toolBox` 模块内，文件名应具有明确语义，**禁止**使用 `index.js` 或 `main.js`。
    *   **导出:** 强制使用命名导出，禁止默认导出。
6.  **代码组织与层级提升原则 (高内聚、低耦合):**
    *   **起点: 模块内工具:** 功能模块（如 UI 面板、组件、后端服务）应首先将**仅供自身使用**的辅助函数组织在模块内部的 `utils` 或 `helpers` 子目录中。
    *   **中间层: 共享工具:** 如果一个工具函数被**同一层级**的多个模块需要（例如，多个 UI 组件都需要某个 DOM 操作辅助函数），则应将其提升到该层级的共享目录（例如 `source/UI/utils/` 或 `source/UI/composables/`）。组件应优先依赖这些共享工具，而非直接依赖底层 `toolBox`。
    *   **顶层: 全局 ToolBox:** 只有当一个工具函数**完全独立于具体业务、UI 或特定应用场景**，具有广泛的普适性（如纯粹的数学计算、字符串处理、数据结构操作、底层 API 封装等），才应将其放入全局 `src/toolBox/` 中对应的 `base` 或 `feature` 目录。
    *   **目标:** 通过明确的层级划分和依赖方向，实现模块的高内聚（自身功能完整）和低耦合（减少对外部具体实现的依赖）。
7.  **模块化设计**:
    *   按功能域组织工具。
    *   相关功能放在同一目录。
    *   文件过长时及时拆分。
8.  **错误处理**:
    *   提供明确的错误处理机制。
    *   返回有意义的错误信息。
    *   支持错误恢复策略 (如果适用)。

## 文件夹规范

**目标:** 确保 `toolBox` 内每个功能性文件夹都有明确的职责范围和代码准入标准。

**要求:**
- **强制性:** `toolBox` 下的**每一个**功能性子文件夹（无论位于 `base`, `feature`, `useAge`/`domain` 哪一层）都**必须**包含一个 `README.md` 或 `AInote.md` 文件。
- **内容:** 该文件必须清晰地：
    1.  **定义该文件夹的职责范围 (Scope):** 说明这个文件夹里的代码是用来做什么的。
    2.  **明确代码准入标准 (Criteria):** 根据 `toolBox` 的整体三层架构（Base/Feature/Domain），说明什么样的代码**才被允许**放在这个文件夹里。例如，明确指出它属于哪一层，以及它应该（或不应该）依赖哪些其他模块。
    3.  **链接总纲:** 必须包含指向 `toolBox` 根目录下架构说明文件 `[architecture_layers_explained.md](./architecture_layers_explained.md)` 的链接，作为统一的架构指导。
- **示例:** （在具体文件夹的 `README.md` 或 `AInote.md` 中）
    ```markdown
    # 文件夹名称 (例如: base/lang/functions)

    **所属层级:** Base

    **职责范围:** 提供与 ECMAScript 函数相关的底层、通用工具，如函数组合、柯里化、节流、防抖等。

    **准入标准:**
    - 必须是纯粹的、与函数操作相关的底层工具。
    - 必须无副作用（除非明确标记并隔离）。
    - **禁止**依赖 `feature` 或 `domain` 层的任何模块。
    - **禁止**包含特定应用的业务逻辑。
    - 外部依赖必须通过 `base/deps` 引入。

    **架构总纲:** [../../../architecture_layers_explained.md](../../../architecture_layers_explained.md) (根据实际层级调整路径)
    ```
- **维护:** 创建新文件夹或对文件夹职责进行重大调整时，必须同步创建或更新对应的说明文件。

## 导入导出规范

**核心目标:** 确保工具箱作为长期个人代码库的清晰性、可维护性和可扩展性。

**规范:**
- **严格禁止** 使用 `import *` 和 `export *`。
- **放弃** `*Exports.js` 等桶文件作为主要的模块导出方式。
- **强制** 使用**命名导出** (`export const func = ...;`)，禁止默认导出 (`export default`)。
- **强制** 使用**明确、直接的相对路径**进行模块导入：
    - 层内导入: `import { util } from '../anotherModule/util.js';`
    - 跨层导入: `import { baseFunc } from '../../base/someModule/file.js';`
    - 外部导入: (推荐配置路径别名如 `@toolBox/`) `import { tool } from '@toolBox/feature/someTool/index.js';`
- **优点:** 依赖清晰、利于 Tree Shaking、重构友好、避免循环依赖陷阱。
- **接受:** 导入路径可能变长，可通过路径别名缓解。

## 外部依赖管理原则 (`useDeps`)

**核心原则 (绝对强制):** 项目代码库 (包括 `src/toolBox` 和 `source/` 目录) 中对**任何外部依赖**的引用，**必须**通过 `src/toolBox/base/deps/` 目录进行统一引入和封装。**严禁**在 `deps` 目录之外直接 `import` 或 `require` 任何：
*   NPM 包 (来自 `node_modules`)
*   `static/` 目录下的第三方 JS 文件
*   Node.js 内建模块 (如 `fs`, `path`, `os` 等，应使用 `toolBox` 内对应的 `useNode` 封装)

**实现方式:** 在 `src/toolBox/base/deps/` 下为每个外部依赖创建子目录和入口文件 (如 `lodash/index.js`, `nodeFs/index.js`)，在该文件中导入实际依赖并重导出需要的部分。

**目标:**
*   集中管理所有外部依赖及其版本。
*   提供稳定、统一的内部接口，隔离外部实现细节和变化。
*   极大简化依赖关系追踪、更新和维护。
*   确保 `toolBox` 和 `source` 的任何部分都不会意外地直接耦合到某个外部库或特定环境 API。

**特定依赖说明:**
*   **Vue 核心响应式:** (此前的具体说明现在被上述通用规则覆盖，但保留作为示例)
    *   对 `@vue/reactivity` 核心 API 的使用，**必须**通过 `src/toolBox/base/deps/vue/vueReactivity.js` 导入。
    *   Vue 生命周期钩子目前建议直接从 `static/vue.esm-browser.js` 导入，**此为例外情况，后续需统一处理** (例如在 `deps` 中提供专门的 `vueLifecycle.js` 或在 UI 层提供封装)。

## 其他重要原则 (来自 AInote.md)

### 依赖位置原则

为确保职责清晰和避免反向依赖：

1.  **第三方库:**
    *   **npm 依赖:** 保留在 `node_modules`，通过 `base/useDeps` 统一引入和封装后使用。
    *   **独立 JS 文件:** 放置在根目录 `static/` 下，同样通过 `base/useDeps` 统一引入和封装后使用。
2.  **内部模块:**
    *   **核心/底层 (`src/toolBox/`):**
        *   通用、独立、无业务逻辑的工具。
        *   **禁止**反向依赖应用层 (`source/`)。
        *   配置项应通过函数参数传入，而非直接读取应用层配置。
    *   **应用/UI (`source/`):**
        *   包含业务逻辑、UI 组件、页面特定代码。
        *   可以依赖 `toolBox`。
        *   内部可进一步按功能划分 (如 `UI/`, `server/`, `data/`)。

### 性能优化策略

1. **延迟加载**
   - 非核心功能采用动态导入 (`import()`)。
   - 按需加载减少初始加载时间。

2. **函数优化**
   - 对计算密集或重复调用的纯函数使用记忆化 (Memoization)。
   - 针对大数据量操作考虑批处理机制。

3. **资源管理**
   - 对可复用的计算结果或资源进行适当缓存。
   - 使用资源池管理可重用对象（如数据库连接、WebSocket 连接）。

### 测试与文档

1. **单元测试**
   - `toolBox` 中每个导出的工具函数原则上都应有单元测试。
   - 重点测试边界条件和异常情况。
   - 测试覆盖率作为代码质量的重要指标。

2. **文档生成**
   - 使用 JSDoc 注释为所有导出的函数、类型、常量编写文档。
   - 文档应清晰说明功能、参数、返回值、用法示例和注意事项。 