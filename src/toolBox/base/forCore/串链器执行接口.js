import { 构建新态射重载表项目,插入新态射 } from "./串链器态射定义.js";
import  * as 工具 from './串链器工具.js'
export const 创建定义接口 = (全局态射表, 命名空间态射表) => {
    let 是方法状态 = false;
    let 当前命名空间 = '';
    const 定义器 = {
        /**
         * 设置方法状态,用于区分方法和普通属性
         * 方法状态下定义的态射,调用对象会是当前值,而不是定义器代理
         * @returns 
         */
        $方法() {
            是方法状态 = true;
            return 定义器代理;
        },
        方法$() {
            是方法状态 = false;
            return 定义器代理;
        },
        命名空间(名称) {
            当前命名空间 = 名称;
            if (!命名空间态射表.has(名称)) {
                命名空间态射表.set(名称, new Map());
            }
            return 定义器代理;
        },
        退出命名空间() {
            当前命名空间 = '';
            return 定义器代理;
        },
        态射(名称, 实现或对象, 匹配器) {
            let 目标态射表 = 全局态射表;
            let 完整名称 = 名称;
            if (当前命名空间) {
                目标态射表 = 命名空间态射表.get(当前命名空间);
                完整名称 = `${当前命名空间}.${名称}`;
            }
            if (!目标态射表.has(名称)) {
                目标态射表.set(名称, []);
            }
            const 态射定义 = 构建新态射重载表项目(实现或对象, 是方法状态, 目标态射表, 匹配器);
            插入新态射(目标态射表, 名称, 态射定义, 匹配器);
            return 定义器代理;
        },
        // 自然变换
        _(目标上下文, 目标名称, 变换实现, 匹配器) {
            if (!工具.是串链器(目标上下文)) {
                throw new Error('自然变换的目标上下文必须是一个串链器');
            }

            const 自然变换名 = `_${目标名称}_`;
            this.态射(自然变换名, (源值, ...参数) => {
                const 变换结果 = 变换实现(源值, ...参数);
                return 目标上下文(变换结果);
            }, 匹配器);

            return 定义器代理;
        }
    };
    const 定义器代理 = new Proxy(定义器, {
        get(目标, 属性) {
            if (属性 in 目标) return 目标[属性];
            if (属性.startsWith('$')&&属性.endsWith('$')) {
                let 脱壳命名空间 = 属性.slice(1, -1);
                console.log('定义命名空间',脱壳命名空间);
                当前命名空间 = 脱壳命名空间;
                if (!命名空间态射表.has(脱壳命名空间)) {
                    命名空间态射表.set(脱壳命名空间, new Map());
                }
                return 定义器代理;
            }
            return (实现, 匹配器) => 目标.态射(属性, 实现, 匹配器);
        }
    });
    return 定义器代理;
};
