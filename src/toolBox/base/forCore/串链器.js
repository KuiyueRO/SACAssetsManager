/**
 * 串链器 - 用于构建灵活的链式API
 * 
 * ## 核心功能
 * 
 * ### 1. 基础链式调用
 * - 方法注册与调用：动态注册方法并保持链式调用
 * - 值传递管理：控制链中数据的流动和转换
 * - 上下文隔离：为不同链提供独立上下文
 * - 终止器支持：允许链式调用终止并返回值
 * 
 * ### 2. 基础编程模型
 * - 条件链：基于条件执行不同链路分支
 * - 管道转换：支持函数式编程的管道模式
 * - 基础上下文切换：在链中切换执行环境
 * 
 * ### 3. 基础错误处理
 * - 链内错误传播：简单的错误处理机制
 * 
 * ## 扩展功能（需要额外实现）,要求可插拔
 * 
 * ### 1. 高级链式模式
 * - 分支合并：支持多条链路的分叉与合并
 * - 异步链：支持Promise与异步操作
 * - 链路监听：在链路执行过程中插入钩子函数
 * 
 * ### 2. 高级DSL构建
 * - 方法分组：将相关方法组织到命名空间中
 * - 复杂上下文管理：高级上下文与作用域控制
 * - 链式体验优化：更自然的API语法和流程控制
 * 
 * ### 3. 调试与维护工具
 * - 链路追踪：记录链式调用路径便于调试
 * - 高级错误处理：错误恢复与降级策略
 * - 性能优化：减少链式调用的性能开销
 * - 可序列化：支持链式调用的存储与恢复
 * 
 * ### 4. 互操作性
 * - 外部链整合：与第三方链式库协同工作
 * - 适配器模式：转换不同形式的链式API
 * - 组合复用：链式片段的封装与复用
 */

import { 创建扩展管理器, 创建扩展定义, 配置扩展管理 } from './串链器扩展.js';
import { 是串链器,标记串链器,串链器标记,获取原始值 } from './useChainableHelper.js';
import { 创建定义接口 } from './串链器执行接口.js';
// 常量和符号定义
// 简化分支处理函数
const 处理分支 = (当前值, 条件映射, 默认分支) => {
    // 处理函数数组形式
    console.log(当前值, 条件映射, 默认分支);
    if (Array.isArray(条件映射)) {
        for (const [条件, 处理] of 条件映射) {
            if (条件(当前值)) {
                return 处理(当前值);
            }
        }
        return 默认分支?.(当前值) ?? 当前值;
    }

    // 处理对象形式 - 仅保留简单的键值映射
    if (typeof 条件映射 === 'object') {
        const 分支键 = Object.keys(条件映射).find(键 => 条件映射[键].条件?.(当前值));
        return 分支键 ?
            条件映射[分支键].处理(当前值) :
            (默认分支?.(当前值) ?? 当前值);
    }

    return 当前值;
};

// 串链器构造器
const 创建串链器 = (配置 = {}) => {
    const 全局态射表 = new Map();
    const 命名空间态射表 = new Map();
    const 扩展管理器 = 创建扩展管理器();
    const 定义接口 = 创建定义接口(全局态射表, 命名空间态射表);

    // 注册基础钩子点
    扩展管理器
        .注册钩子点('前置处理', 值 => 值)
        .注册钩子点('后置处理', 值 => 值)
        .注册钩子点('态射执行前', (态射名, 当前值, 参数) => ({ 态射名, 当前值, 参数 }))
        .注册钩子点('态射执行后', (态射名, 执行结果, 原始值) => 执行结果)
        .注册钩子点('错误处理', (错误, 上下文) => { throw 错误; })
    //这里需要添加分支决策钩子和分支合并钩子
    // 初始化主函数
    const 主函数 = (初始值) => {
        const 执行接口 = 创建执行接口(全局态射表, 命名空间态射表, 初始值);
        return 执行接口;
    };


    // 外部配置扩展管理
    配置扩展管理(主函数, 扩展管理器, 定义接口, 全局态射表, 命名空间态射表);

    //创建执行接口
    //执行接口调用时,使用代理,代理中调用扩展管理器中的钩子
    /***
     * 类似 链(1).加法(2).乘法(3).值
     * 每一步调用的结果,都会被代理,以便于下一步继续链式调用
     */
    const 创建执行接口 = (全局态射表, 命名空间态射表, 初始值) => {
        let 当前值 = 扩展管理器.执行钩子('前置处理', 初始值);
        let 当前命名空间 = '';
        let 代理执行接口;

       

        // 查找态射定义
        const 查找态射 = (名称) => {
            // 先检查当前命名空间
            if (当前命名空间) {
                const 命名空间表 = 命名空间态射表.get(当前命名空间);
                if (命名空间表 && 命名空间表.has(名称)) {
                    return { 态射列表: 命名空间表.get(名称), 完整名称: `${当前命名空间}.${名称}` };
                }
            }

            // 再检查全局态射表
            if (全局态射表.has(名称)) {
                return { 态射列表: 全局态射表.get(名称), 完整名称: 名称 };
            }

            return null;
        };

        const 代理 = new Proxy({}, {
            get(目标, 属性) {
                console.log('开始查询属性',目标,属性);
                const 是命名空间语法 = (属性) => {

                    return typeof 属性 === 'string' && 属性.startsWith('$') && 属性.endsWith('$') ;
                };
                // 特殊命令处理
                if (是命名空间语法(属性)) {

                    return (名称) => {
                        let 脱壳命名空间 = 属性.slice(1, -1);
                        if (命名空间态射表.has(脱壳命名空间)) {
                            命名空间态射表.set(Symbol.for('串链器命名空间'),脱壳命名空间);
                        } else {
                            throw new Error(`未定义的命名空间: ${脱壳命名空间}`);
                        }
                        return 代理执行接口;
                    }
                }

                // 安全地处理Symbol属性
                if (typeof 属性 === 'symbol') {
                    if (属性 === 串链器标记) return true;
                    return undefined;
                }
                // 处理 Promise 相关方法
                if (属性 === 'then' || 属性 === 'catch' || 属性 === 'finally') {
                    return (...参数) => {
                        const 当前Promise = Promise.resolve(当前值);
                        let promise;

                        if (属性 === 'then') {
                            promise = 当前Promise.then(值 => {
                                if (参数[0]) {
                                    const 结果 = 参数[0](值);
                                    // 如果 then 的回调返回了串链器或Promise,递归处理
                                    if (是串链器(结果)) {
                                        return 结果.值;
                                    } else if (结果 && typeof 结果.then === 'function') {
                                        return 结果.then(异步值 =>
                                            是串链器(异步值) ? 异步值.值 : 异步值
                                        );
                                    }
                                    return 结果;
                                }
                                return 值;
                            }, 参数[1]);
                        } else {
                            promise = 当前Promise[属性](...参数);
                        }

                        // 为返回的 Promise 添加代理
                        return new Proxy(promise, {
                            get(目标, 新属性) {
                                // 保持 Promise 原生方法
                                if (新属性 === 'then' || 新属性 === 'catch' || 新属性 === 'finally') {
                                    return (...新参数) => {
                                        const 新Promise = 目标[新属性](...新参数);
                                        return new Proxy(新Promise, this);
                                    };
                                }

                                // 允许继续链式调用
                                return (...新参数) => {
                                    return new Proxy(
                                        目标.then(值 => {
                                            当前值 = 值;
                                            return 代理执行接口[新属性](...新参数);
                                        }),
                                        this
                                    );
                                };
                            }
                        });
                    };
                }
    

                if (属性 === '值') {
                    return 获取原始值(扩展管理器.执行钩子('后置处理', 当前值));
                }
                if (属性 === '使用命名空间') {
                    return (名称) => {
                        if (命名空间态射表.has(名称)) {
                            当前命名空间 = 名称;
                        } else {
                            throw new Error(`未定义的命名空间: ${名称}`);
                        }
                        return 代理执行接口;
                    };
                }

                if (属性 === '退出命名空间') {
                    return () => {
                        当前命名空间 = '';
                        return 代理执行接口;
                    };
                }

                // 在执行接口中使用简化的分支API
                if (属性 === '分支') {
                    return (条件映射, 默认分支) => {
                        console.log(当前值, 条件映射, 默认分支);

                        当前值 = 处理分支(当前值, 条件映射, 默认分支);
                        return 代理执行接口;
                    };
                }

                // 在执行接口中增加简单的条件方法
                if (属性 === 'if') {
                    return (条件, 真值处理, 假值处理) => {
                        const 条件结果 = typeof 条件 === 'function' ? 条件(当前值) : Boolean(条件);

                        if (条件结果) {
                            当前值 = 真值处理(当前值);
                        } else if (假值处理) {
                            当前值 = 假值处理(当前值);
                        }

                        // 处理当前值为串链器的情况
                        if (当前值 && typeof 当前值 === 'object' && 是串链器(当前值)) {
                            当前值 = 当前值.值;
                        }

                        return 代理执行接口;
                    };
                }

                // 查找态射
                const 态射信息 = 查找态射(属性);
                if (态射信息) {
                    return (...参数) => {
                        try {
                            // 执行态射前钩子
                            const 钩子结果 = 扩展管理器.执行钩子('态射执行前', 态射信息.完整名称, 当前值, 参数);
                            console.log(态射信息.态射列表);
                            //这里i不止要传递参数,还要传递值
                            const 匹配态射 = 态射信息.态射列表.find(态射 => 态射.匹配器(钩子结果.当前值, ...钩子结果.参数));

                            if (!匹配态射) throw new Error(`未找到匹配的态射实现: ${态射信息.完整名称}`);
                            const 执行结果 = 匹配态射.实现(钩子结果.当前值, ...钩子结果.参数);

                            // 处理异步结果,通过.then判断执行结果是不是Promise
                            if (执行结果 && typeof 执行结果.then === 'function') {
                               // const 异步执行包装器 = 创建异步包装器(执行结果, 当前值, 态射信息,代理执行接口, 扩展管理器, 匹配态射);
                                const 异步执行包装器 = 执行结果.then(异步结果 => {
                                    // 递归处理嵌套的Promise结果
                                    if (异步结果 && typeof 异步结果.then === 'function') {
                                        return 异步结果.then(最终结果 => {
                                            const 处理后结果 = 扩展管理器.执行钩子('态射执行后', 态射信息.完整名称, 最终结果, 当前值);
                                            if (匹配态射.直接返回) {
                                                return 处理后结果;
                                            }
                                            当前值 = 处理后结果;
                                            return 代理执行接口;
                                        });
                                    }
                                    const 处理后结果 = 扩展管理器.执行钩子('态射执行后', 态射信息.完整名称, 异步结果, 当前值);
                                    if (匹配态射.直接返回) {
                                        return 处理后结果;
                                    }
                                    当前值 = 处理后结果;
                                    return 代理执行接口;
                                }).catch(错误 => {
                                    return 扩展管理器.执行钩子('错误处理', 错误, {
                                        态射名: 态射信息.完整名称,
                                        当前值,
                                        代理接口: 代理执行接口
                                    });
                                });

                                // 为异步执行包装器添加代理
                                return new Proxy(异步执行包装器, {
                                    get(目标, 属性) {
                                        // 处理原生Promise方法
                                        if (属性 === 'then' || 属性 === 'catch' || 属性 === 'finally') {
                                            return (...参数) => {
                                                const 新Promise = 目标[属性](...参数);
                                                return new Proxy(新Promise, this);
                                            };
                                        }

                                        // 处理值属性
                                        if (属性 === '值') {
                                            return 目标;
                                        }

                                        // 处理其他方法调用
                                        return (...新参数) => {
                                            return new Proxy(
                                                目标.then(结果 => {
                                                    if (是串链器(结果)) {
                                                        return 结果[属性](...新参数);
                                                    }
                                                    当前值 = 结果;
                                                    return 代理执行接口[属性](...新参数);
                                                }),
                                                this
                                            );
                                        };
                                    }
                                });
                            }

                            // 执行态射后钩子
                            const 处理后结果 = 扩展管理器.执行钩子('态射执行后', 态射信息.完整名称, 执行结果, 当前值);

                            if (匹配态射.直接返回) return 处理后结果;

                            当前值 = 处理后结果;
                            return 代理执行接口;
                        } catch (错误) {
                            return 扩展管理器.执行钩子('错误处理', 错误, {
                                态射名: 态射信息.完整名称,
                                当前值,
                                参数,
                                代理接口: 代理执行接口
                            });
                        }
                    };
                }

                // 检查是否是原生方法
                const 原始值 = 获取原始值(当前值);
                if (原始值 != null && 属性 in Object(原始值)) {
                    const 目标方法 = 原始值[属性];
                    if (typeof 目标方法 === 'function') {
                        return (...参数) => {
                            try {
                                const 执行结果 = 目标方法.apply(原始值, 参数);

                                if (执行结果 && typeof 执行结果.then === 'function') {
                                    const 异步包装器 = 执行结果.then(异步结果 => {
                                        if (异步结果 && typeof 异步结果.then === 'function') {
                                            return 异步结果.then(最终结果 => {
                                                当前值 = 最终结果;
                                                return 代理执行接口;
                                            });
                                        }
                                        当前值 = 异步结果;
                                        return 代理执行接口;
                                    });

                                    return new Proxy(异步包装器, {
                                        get(目标, 新属性) {
                                            // 处理原生Promise方法
                                            if (新属性 === 'then' || 新属性 === 'catch' || 新属性 === 'finally') {
                                                return (...新参数) => {
                                                    const 新Promise = 目标[新属性](...新参数);
                                                    return new Proxy(新Promise, this);
                                                };
                                            }

                                            // 处理值属性
                                            if (新属性 === '值') {
                                                return 目标;
                                            }

                                            // 处理其他方法调用
                                            return (...新参数) => {
                                                return new Proxy(
                                                    目标.then(结果 => {
                                                        if (是串链器(结果)) {
                                                            return 结果[新属性](...新参数);
                                                        }
                                                        当前值 = 结果;
                                                        return 代理执行接口[新属性](...新参数);
                                                    }),
                                                    this
                                                );
                                            };
                                        }
                                    });
                                }

                                当前值 = 执行结果;
                                return 代理执行接口;
                            } catch (错误) {
                                return 扩展管理器.执行钩子('错误处理', 错误, {
                                    方法名: 属性,
                                    当前值,
                                    参数,
                                    代理接口: 代理执行接口
                                });
                            }
                        };
                    }
                }

                throw new Error(`未定义的态射: ${属性}`);
            }
        });

        代理执行接口 = 代理;
        return 代理执行接口;
    };
    return 创建带有定义接口代理的主函数(主函数, 定义接口);

};
/**
 * 创建带有定义接口代理的主函数
 * 这样在使用串链器时,可以使用链.命名空间.方法() 的方式调用来定义
 * 使用链().命名空间().方法() 的方式来调用
 * @param {*} 主函数 
 * @param {*} 定义接口实例 
 * @returns 
 */
const 创建带有定义接口代理的主函数 = (主函数,定义接口实例) => {
    return new Proxy(主函数, {
        get(目标, 属性) {
            if (typeof 属性 === 'symbol') {
                if (属性 === 串链器标记) return true;
                return undefined;
            }

            if (属性 === 'prototype' || 属性 === 'length' || 属性 === 'name' ||
                属性 === '扩展') {
                return 目标[属性];
            }
            return 定义接口实例[属性];
        }
    });

}
export { 创建串链器, 创建扩展定义 };


