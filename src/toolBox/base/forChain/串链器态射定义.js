export function 插入新态射(链全局态射表, 名称, 态射定义, 匹配器) {
    const 态射重载表 = 链全局态射表.get(名称);

    if (匹配器) {
        态射定义.匹配器长度 = 匹配器.length;
        // 1. 找到第一个匹配器长度小于当前匹配器的位置
        // 2. 对于相同长度的匹配器，插入到这些匹配器之前（保证后插入的优先匹配）
        const 插入位置 = 态射重载表.findIndex(已有态射 => 
            已有态射.是默认态射 || 
            (已有态射.匹配器长度 || 0) <= 态射定义.匹配器长度
        );
        
        if (插入位置 === -1) {
            态射重载表.push(态射定义);
        } else {
            态射重载表.splice(插入位置, 0, 态射定义);
        }
    } else {
        态射定义.是默认态射 = true;
        // 默认态射总是放在最后
        态射重载表.push(态射定义);
    }
    console.log(态射重载表,名称);
}

export const 构建新态射重载表项目 = (实现或对象, 链是方法状态, 目标态射表, 匹配器) => {
    // 处理匹配器数组
    const 规范化匹配器 = 匹配器
        ? Array.isArray(匹配器)
            ? (...参数) => 匹配器.every(单个匹配器 =>{ 
                console.log(单个匹配器,参数);
                return 单个匹配器(...参数);
            })
            : 匹配器
        : () => true;
    return {
        实现: typeof 实现或对象 === 'function'
            ? (当前值, ...参数) => {
                if (链是方法状态) return 实现或对象(当前值);
                return 实现或对象(当前值, ...参数);
            }
            : (当前值, ...参数) => {
                const 上下文 = {};
                Object.entries(实现或对象).forEach(([键, 值]) => {
                    上下文[键] = typeof 值 === 'function' ? 值.bind(当前值) : 值;
                    if (typeof 值 === 'function' && !目标态射表.has(键)) {
                        目标态射表.set(键, [{
                            实现: (ctx, ...args) => 值.apply(ctx, args),
                            匹配器: () => true,
                            直接返回: 链是方法状态,
                            是默认态射: true
                        }]);
                    }
                });
                return Object.assign({}, 当前值, 上下文);
            },
        匹配器: 规范化匹配器,
        直接返回: 链是方法状态,
        是默认态射: !匹配器,
        匹配器长度: Array.isArray(匹配器) ? 匹配器.length : (匹配器 ? 1 : 0)
    }
}