/**
 * 串链器扩展系统 - 提供可插拔的功能扩展机制
 */

// 扩展管理器
const 创建扩展管理器 = () => {
  const 已安装扩展 = new Map();
  const 扩展钩子点 = new Map();
  
  // 注册钩子点
  const 注册钩子点 = (钩子名称, 默认处理器 = x => x) => {
    if (!扩展钩子点.has(钩子名称)) {
      扩展钩子点.set(钩子名称, {
        处理器列表: [],
        默认处理器
      });
    }
    return 扩展管理器代理;
  };
  
  // 执行钩子
  const 执行钩子 = (钩子名称, 上下文, ...参数) => {
    if (!扩展钩子点.has(钩子名称)) {
      throw new Error(`未定义的钩子点: ${钩子名称}`);
    }
    
    const { 处理器列表, 默认处理器 } = 扩展钩子点.get(钩子名称);
    // 使用reduce串联所有处理器
    return 处理器列表.reduce(
      (当前值, 处理器) => 处理器(当前值, 上下文, ...参数),
      默认处理器(上下文, ...参数)
    );
  };
  
  // 安装扩展
  const 安装扩展 = (扩展ID, 扩展配置 = {}) => {
    if (已安装扩展.has(扩展ID)) {
      console.warn(`扩展 ${扩展ID} 已安装，将被重新安装`);
      卸载扩展(扩展ID);
    }
    
    const 扩展信息 = {
      ID: 扩展ID,
      配置: 扩展配置,
      钩子处理器: new Map(),
      状态: '已安装'
    };
    
    已安装扩展.set(扩展ID, 扩展信息);
    return 扩展管理器代理;
  };
  
  // 注册扩展钩子处理器
  const 注册扩展处理器 = (扩展ID, 钩子名称, 处理器) => {
    if (!已安装扩展.has(扩展ID)) {
      throw new Error(`扩展 ${扩展ID} 未安装`);
    }
    
    if (!扩展钩子点.has(钩子名称)) {
      throw new Error(`未定义的钩子点: ${钩子名称}`);
    }
    
    const 扩展信息 = 已安装扩展.get(扩展ID);
    扩展信息.钩子处理器.set(钩子名称, 处理器);
    
    // 将处理器添加到钩子点的处理器列表
    const 钩子信息 = 扩展钩子点.get(钩子名称);
    钩子信息.处理器列表.push(处理器);
    
    return 扩展管理器代理;
  };
  
  // 卸载扩展
  const 卸载扩展 = (扩展ID) => {
    if (!已安装扩展.has(扩展ID)) {
      return 扩展管理器代理;
    }
    
    const 扩展信息 = 已安装扩展.get(扩展ID);
    
    // 从所有钩子点移除处理器
    扩展信息.钩子处理器.forEach((处理器, 钩子名称) => {
      if (扩展钩子点.has(钩子名称)) {
        const 钩子信息 = 扩展钩子点.get(钩子名称);
        const 索引 = 钩子信息.处理器列表.indexOf(处理器);
        if (索引 !== -1) {
          钩子信息.处理器列表.splice(索引, 1);
        }
      }
    });
    
    已安装扩展.delete(扩展ID);
    return 扩展管理器代理;
  };
  
  // 获取扩展信息
  const 获取扩展信息 = (扩展ID) => {
    return 已安装扩展.get(扩展ID);
  };
  
  // 获取所有已安装扩展
  const 获取所有扩展 = () => {
    return Array.from(已安装扩展.keys());
  };
  
  // 修改钩子行为
  const 修改钩子 = (钩子名称, 处理器) => {
    if (!扩展钩子点.has(钩子名称)) {
      // 如果钩子不存在，先注册它
      注册钩子点(钩子名称);
    }
    
    const 钩子信息 = 扩展钩子点.get(钩子名称);
    钩子信息.处理器列表.push(处理器);
    
    return 扩展管理器代理;
  };
  
  const 扩展管理器 = {
    注册钩子点,
    执行钩子,
    安装扩展,
    注册扩展处理器,
    卸载扩展,
    获取扩展信息,
    获取所有扩展,
    修改钩子
  };
  
  const 扩展管理器代理 = new Proxy(扩展管理器, {
    get(目标, 属性) {
      return 目标[属性];
    }
  });
  
  return 扩展管理器代理;
};

// 扩展定义工厂
const 创建扩展定义 = (配置) => {
  // 支持两种调用方式
  if (typeof 配置 === 'string' && arguments.length > 1) {
    // 兼容旧的调用方式: (扩展ID, 初始化函数)
    const 扩展ID = 配置;
    const 初始化函数 = arguments[1];
    return {
      ID: 扩展ID,
      初始化: 初始化函数
    };
  } else if (typeof 配置 === 'object') {
    // 新的对象参数调用方式
    return {
      ID: 配置.ID,
      版本: 配置.版本 || '1.0.0',
      描述: 配置.描述 || '',
      初始化: 配置.初始化
    };
  } else {
    throw new Error('创建扩展定义：参数格式不正确');
  }
};

export { 创建扩展管理器, 创建扩展定义 }; 