/**
 * 串链器 - 用于构建灵活的链式API
 * 
 * ## 核心功能
 * 
 * ### 1. 基础链式调用
 * - 方法注册与调用：动态注册方法并保持链式调用
 * - 值传递管理：控制链中数据的流动和转换
 * - 上下文隔离：为不同链提供独立上下文
 * - 终止器支持：允许链式调用终止并返回值
 * 
 * ### 2. 基础编程模型
 * - 条件链：基于条件执行不同链路分支
 * - 管道转换：支持函数式编程的管道模式
 * - 基础上下文切换：在链中切换执行环境
 * 
 * ### 3. 基础错误处理
 * - 链内错误传播：简单的错误处理机制
 * 
 * ## 扩展功能（需要额外实现）,要求可插拔
 * 
 * ### 1. 高级链式模式
 * - 分支合并：支持多条链路的分叉与合并
 * - 异步链：支持Promise与异步操作
 * - 链路监听：在链路执行过程中插入钩子函数
 * 
 * ### 2. 高级DSL构建
 * - 方法分组：将相关方法组织到命名空间中
 * - 复杂上下文管理：高级上下文与作用域控制
 * - 链式体验优化：更自然的API语法和流程控制
 * 
 * ### 3. 调试与维护工具
 * - 链路追踪：记录链式调用路径便于调试
 * - 高级错误处理：错误恢复与降级策略
 * - 性能优化：减少链式调用的性能开销
 * - 可序列化：支持链式调用的存储与恢复
 * 
 * ### 4. 互操作性
 * - 外部链整合：与第三方链式库协同工作
 * - 适配器模式：转换不同形式的链式API
 * - 组合复用：链式片段的封装与复用
 */

import { 创建扩展管理器, 创建扩展定义 } from './串链器扩展.js';

// 常量和符号定义
const 串链器标记 = Symbol.for('串链器标记');

// 工具函数
const 工具 = {
    是串链器(目标) {
        try {
            return Boolean(目标?.[串链器标记]);
        } catch (e) {
            // 处理Symbol访问错误
            return false;
        }
    },

    标记串链器(目标) {
        Object.defineProperty(目标, 串链器标记, {
            value: true,
            writable: false,
            enumerable: false,
            configurable: false
        });
        return 目标;
    }
};


// 定义接口构造器
const 创建定义接口 = (全局态射表, 命名空间态射表) => {
    let 是方法状态 = false;
    let 当前命名空间 = '';

    const 定义器 = {
        $方法() {
            是方法状态 = true;
            return 定义器代理;
        },

        方法$() {
            是方法状态 = false;
            return 定义器代理;
        },

        命名空间(名称) {
            当前命名空间 = 名称;
            if (!命名空间态射表.has(名称)) {
                命名空间态射表.set(名称, new Map());
            }
            return 定义器代理;
        },

        退出命名空间() {
            当前命名空间 = '';
            return 定义器代理;
        },

        态射(名称, 实现或对象, 匹配器) {
            let 目标态射表 = 全局态射表;
            let 完整名称 = 名称;

            if (当前命名空间) {
                目标态射表 = 命名空间态射表.get(当前命名空间);
                完整名称 = `${当前命名空间}.${名称}`;
            }

            if (!目标态射表.has(名称)) {
                目标态射表.set(名称, []);
            }

            // 处理匹配器数组
            const 规范化匹配器 = 匹配器
                ? Array.isArray(匹配器)
                    ? (参数) => 匹配器.every(单个匹配器 => 单个匹配器(参数))
                    : 匹配器
                : () => true;

            const 态射定义 = {
                实现: typeof 实现或对象 === 'function'
                    ? (当前值, ...参数) => {
                        if (是方法状态) return 实现或对象(当前值);
                        return 实现或对象(当前值, ...参数);
                    }
                    : (当前值, ...参数) => {
                        const 上下文 = {};
                        Object.entries(实现或对象).forEach(([键, 值]) => {
                            上下文[键] = typeof 值 === 'function' ? 值.bind(当前值) : 值;
                            if (typeof 值 === 'function' && !目标态射表.has(键)) {
                                目标态射表.set(键, [{
                                    实现: (ctx, ...args) => 值.apply(ctx, args),
                                    匹配器: () => true,
                                    直接返回: 是方法状态,
                                    是默认态射: true
                                }]);
                            }
                        });
                        return Object.assign({}, 当前值, 上下文);
                    },
                匹配器: 规范化匹配器,
                直接返回: 是方法状态,
                是默认态射: !匹配器,
                匹配器长度: Array.isArray(匹配器) ? 匹配器.length : (匹配器 ? 1 : 0)
            };

            const 态射列表 = 目标态射表.get(名称);

            if (匹配器) {
                // 根据匹配器长度和注册顺序排序
                const 插入位置 = 态射列表.findIndex(已有态射 =>
                    已有态射.是默认态射 || 已有态射.匹配器长度 < 态射定义.匹配器长度
                );

                if (插入位置 === -1) {
                    态射列表.push(态射定义);
                } else {
                    态射列表.splice(插入位置, 0, 态射定义);
                }
            } else {
                // 无匹配器的态射放在所有有匹配器态射之后
                const 最后有匹配器索引 = 态射列表.findLastIndex(态射 => !态射.是默认态射);
                if (最后有匹配器索引 === -1) {
                    态射列表.unshift(态射定义);
                } else {
                    态射列表.splice(最后有匹配器索引 + 1, 0, 态射定义);
                }

                // 移除之前的默认态射
                for (let i = 态射列表.length - 1; i >= 0; i--) {
                    if (态射列表[i].是默认态射 && i !== 最后有匹配器索引 + 1) {
                        态射列表.splice(i, 1);
                    }
                }
            }

            return 定义器代理;
        },

        // 自然变换
        _(目标上下文, 目标名称, 变换实现, 匹配器) {
            if (!工具.是串链器(目标上下文)) {
                throw new Error('自然变换的目标上下文必须是一个串链器');
            }

            const 自然变换名 = `_${目标名称}_`;
            this.态射(自然变换名, (源值, ...参数) => {
                const 变换结果 = 变换实现(源值, ...参数);
                return 目标上下文(变换结果);
            }, 匹配器);

            return 定义器代理;
        }
    };

    const 定义器代理 = new Proxy(定义器, {
        get(目标, 属性) {
            if (属性 in 目标) return 目标[属性];
            return (实现, 匹配器) => 目标.态射(属性, 实现, 匹配器);
        }
    });

    return 定义器代理;
};

// 简化默认分支路径选择器
const 默认分支路径选择器 = () => 值 => '默认';

// 串链器构造器
const 创建串链器 = (配置 = {}) => {
    const 全局态射表 = new Map();
    const 命名空间态射表 = new Map();
    const 扩展管理器 = 创建扩展管理器();
    const 定义接口 = 创建定义接口(全局态射表, 命名空间态射表);

    // 注册基础钩子点
    扩展管理器
        .注册钩子点('前置处理', 值 => 值)
        .注册钩子点('后置处理', 值 => 值)
        .注册钩子点('态射执行前', (态射名, 当前值, 参数) => ({ 态射名, 当前值, 参数 }))
        .注册钩子点('态射执行后', (态射名, 执行结果, 原始值) => 执行结果)
        .注册钩子点('错误处理', (错误, 上下文) => { throw 错误; })
        .注册钩子点('分支决策', (当前值, 分支条件) => {
            // 修改默认实现，根据当前值自动判断分支路径
            let 路径 = '默认';
            if (分支条件.正数 && 当前值 > 0) 路径 = '正数';
            if (分支条件.零 && 当前值 === 0) 路径 = '零';
            if (分支条件.负数 && 当前值 < 0) 路径 = '负数';
            return { 当前值, 路径 };
        })
        .注册钩子点('分支合并', (分支结果集) => 分支结果集[0] || {});

    // 初始化主函数
    const 主函数 = (初始值) => {
        const 执行接口 = 创建执行接口(全局态射表, 命名空间态射表, 初始值);
        // 确保每个新创建的执行接口都继承主函数的分支路径选择器
        执行接口.分支路径选择 = 主函数.分支路径选择;
        return 执行接口;
    };

    // 初始化分支路径选择器
    主函数.分支路径选择 = 默认分支路径选择器;

    // 修改执行接口构造器，支持异步和命名空间
    const 创建执行接口 = (全局态射表, 命名空间态射表, 初始值) => {
        let 当前值 = 扩展管理器.执行钩子('前置处理', 初始值);
        let 当前命名空间 = '';
        let 代理执行接口;

        // 获取原始值
        const 获取原始值 = (值) => {
            if (值 && typeof 值 === 'object' && '值' in 值) return 值.值;
            return 值;
        };

        // 查找态射定义
        const 查找态射 = (名称) => {
            // 先检查当前命名空间
            if (当前命名空间) {
                const 命名空间表 = 命名空间态射表.get(当前命名空间);
                if (命名空间表 && 命名空间表.has(名称)) {
                    return { 态射列表: 命名空间表.get(名称), 完整名称: `${当前命名空间}.${名称}` };
                }
            }

            // 再检查全局态射表
            if (全局态射表.has(名称)) {
                return { 态射列表: 全局态射表.get(名称), 完整名称: 名称 };
            }

            return null;
        };

        const 代理 = new Proxy({}, {
            get(目标, 属性) {

                // 安全地处理Symbol属性
                if (typeof 属性 === 'symbol') {
                    if (属性 === 串链器标记) return true;
                    return undefined;
                }
                // 处理 Promise 相关方法
                if (属性 === 'then' || 属性 === 'catch' || 属性 === 'finally') {
                    return (...参数) => {
                        const 当前Promise = Promise.resolve(当前值);
                        let promise;

                        if (属性 === 'then') {
                            promise = 当前Promise.then(值 => {
                                if (参数[0]) {
                                    const 结果 = 参数[0](值);
                                    // 如果 then 的回调返回了串链器或Promise,递归处理
                                    if (工具.是串链器(结果)) {
                                        return 结果.值;
                                    } else if (结果 && typeof 结果.then === 'function') {
                                        return 结果.then(异步值 =>
                                            工具.是串链器(异步值) ? 异步值.值 : 异步值
                                        );
                                    }
                                    return 结果;
                                }
                                return 值;
                            }, 参数[1]);
                        } else {
                            promise = 当前Promise[属性](...参数);
                        }

                        // 为返回的 Promise 添加代理
                        return new Proxy(promise, {
                            get(目标, 新属性) {
                                // 保持 Promise 原生方法
                                if (新属性 === 'then' || 新属性 === 'catch' || 新属性 === 'finally') {
                                    return (...新参数) => {
                                        const 新Promise = 目标[新属性](...新参数);
                                        return new Proxy(新Promise, this);
                                    };
                                }

                                // 允许继续链式调用
                                return (...新参数) => {
                                    return new Proxy(
                                        目标.then(值 => {
                                            当前值 = 值;
                                            return 代理执行接口[新属性](...新参数);
                                        }),
                                        this
                                    );
                                };
                            }
                        });
                    };
                }                // 特殊属性处理 - 关键修改点：添加分支路径选择的特殊处理
                if (属性 === '分支路径选择') {
                    return 主函数.分支路径选择;
                }

                if (属性 === '值') {
                    return 获取原始值(扩展管理器.执行钩子('后置处理', 当前值));
                }

                // 特殊命令处理
                if (属性 === '使用命名空间') {
                    return (名称) => {
                        if (命名空间态射表.has(名称)) {
                            当前命名空间 = 名称;
                        } else {
                            throw new Error(`未定义的命名空间: ${名称}`);
                        }
                        return 代理执行接口;
                    };
                }

                if (属性 === '退出命名空间') {
                    return () => {
                        当前命名空间 = '';
                        return 代理执行接口;
                    };
                }

                // 分支支持 - 极简版
                if (属性 === '分支') {
                    return (条件映射, 默认分支) => {
                        let 分支结果 = 当前值;

                        // 处理数组形式 - 函数条件优先
                        if (Array.isArray(条件映射)) {
                            let 已匹配 = false;

                            // 支持单个条件对或多个条件对数组
                            const 条件列表 = Array.isArray(条件映射[0]) ? 条件映射 : [条件映射];

                            for (const 条件项 of 条件列表) {
                                if (Array.isArray(条件项) && 条件项.length >= 2) {
                                    const [条件函数, 处理函数] = 条件项;

                                    if (typeof 条件函数 === 'function' && typeof 处理函数 === 'function') {
                                        try {
                                            if (条件函数(当前值)) {
                                                分支结果 = 处理函数(当前值);
                                                已匹配 = true;
                                                break;
                                            }
                                        } catch (e) {
                                            console.error('条件函数执行错误:', e);
                                        }
                                    }
                                }
                            }

                            // 未匹配时使用默认分支
                            if (!已匹配 && typeof 默认分支 === 'function') {
                                分支结果 = 默认分支(当前值);
                            }
                        }
                        // 处理对象形式 - 简化的类型和值匹配
                        else if (条件映射 && typeof 条件映射 === 'object') {
                            let 已匹配 = false;

                            // 1. 先检查特殊值
                            if (当前值 === null && '空值' in 条件映射) {
                                分支结果 = 条件映射['空值'](当前值);
                                已匹配 = true;
                            }
                            else if (当前值 === undefined && '未定义' in 条件映射) {
                                分支结果 = 条件映射['未定义'](当前值);
                                已匹配 = true;
                            }

                            // 2. 再检查类型
                            if (!已匹配) {
                                const 类型 = typeof 当前值;
                                if (类型 in 条件映射) {
                                    分支结果 = 条件映射[类型](当前值);
                                    已匹配 = true;
                                }
                            }

                            // 3. 最后是默认分支
                            if (!已匹配) {
                                if (typeof 默认分支 === 'function') {
                                    分支结果 = 默认分支(当前值);
                                } else if ('默认' in 条件映射) {
                                    分支结果 = 条件映射['默认'](当前值);
                                }
                            }
                        }

                        // 处理结果为串链器的情况 - 简化版
                        if (分支结果 && typeof 分支结果 === 'object' && '值' in 分支结果) {
                            分支结果 = 分支结果.值;
                        }

                        当前值 = 分支结果;
                        return 代理执行接口;
                    };
                }

                // 在执行接口中增加简单的条件方法
                if (属性 === 'if') {
                    return (条件, 真值处理, 假值处理) => {
                        const 条件结果 = typeof 条件 === 'function' ? 条件(当前值) : Boolean(条件);

                        if (条件结果) {
                            当前值 = 真值处理(当前值);
                        } else if (假值处理) {
                            当前值 = 假值处理(当前值);
                        }

                        // 处理当前值为串链器的情况
                        if (当前值 && typeof 当前值 === 'object' && 工具.是串链器(当前值)) {
                            当前值 = 当前值.值;
                        }

                        return 代理执行接口;
                    };
                }

                // 查找态射
                const 态射信息 = 查找态射(属性);
                if (态射信息) {
                    return (...参数) => {
                        try {
                            // 执行态射前钩子
                            const 钩子结果 = 扩展管理器.执行钩子('态射执行前', 态射信息.完整名称, 当前值, 参数);
                            const 匹配态射 = 态射信息.态射列表.find(态射 => 态射.匹配器(钩子结果.参数));

                            if (!匹配态射) throw new Error(`未找到匹配的态射实现: ${态射信息.完整名称}`);
                            const 执行结果 = 匹配态射.实现(钩子结果.当前值, ...钩子结果.参数);

                            // 处理异步结果
                            if (执行结果 && typeof 执行结果.then === 'function') {
                                const 异步执行包装器 = 执行结果.then(异步结果 => {
                                    // 递归处理嵌套的Promise结果
                                    if (异步结果 && typeof 异步结果.then === 'function') {
                                        return 异步结果.then(最终结果 => {
                                            const 处理后结果 = 扩展管理器.执行钩子('态射执行后', 态射信息.完整名称, 最终结果, 当前值);
                                            if (匹配态射.直接返回) {
                                                return 处理后结果;
                                            }
                                            当前值 = 处理后结果;
                                            return 代理执行接口;
                                        });
                                    }
                                    const 处理后结果 = 扩展管理器.执行钩子('态射执行后', 态射信息.完整名称, 异步结果, 当前值);
                                    if (匹配态射.直接返回) {
                                        return 处理后结果;
                                    }
                                    当前值 = 处理后结果;
                                    return 代理执行接口;
                                }).catch(错误 => {
                                    return 扩展管理器.执行钩子('错误处理', 错误, {
                                        态射名: 态射信息.完整名称,
                                        当前值,
                                        代理接口: 代理执行接口
                                    });
                                });

                                // 为异步执行包装器添加代理
                                return new Proxy(异步执行包装器, {
                                    get(目标, 属性) {
                                        // 处理原生Promise方法
                                        if (属性 === 'then' || 属性 === 'catch' || 属性 === 'finally') {
                                            return (...参数) => {
                                                const 新Promise = 目标[属性](...参数);
                                                return new Proxy(新Promise, this);
                                            };
                                        }

                                        // 处理值属性
                                        if (属性 === '值') {
                                            return 目标;
                                        }

                                        // 处理其他方法调用
                                        return (...新参数) => {
                                            return new Proxy(
                                                目标.then(结果 => {
                                                    if (工具.是串链器(结果)) {
                                                        return 结果[属性](...新参数);
                                                    }
                                                    当前值 = 结果;
                                                    return 代理执行接口[属性](...新参数);
                                                }),
                                                this
                                            );
                                        };
                                    }
                                });
                            }

                            // 执行态射后钩子
                            const 处理后结果 = 扩展管理器.执行钩子('态射执行后', 态射信息.完整名称, 执行结果, 当前值);

                            if (匹配态射.直接返回) return 处理后结果;

                            当前值 = 处理后结果;
                            return 代理执行接口;
                        } catch (错误) {
                            return 扩展管理器.执行钩子('错误处理', 错误, {
                                态射名: 态射信息.完整名称,
                                当前值,
                                参数,
                                代理接口: 代理执行接口
                            });
                        }
                    };
                }

                // 检查是否是原生方法
                const 原始值 = 获取原始值(当前值);
                if (原始值 != null && 属性 in Object(原始值)) {
                    const 目标方法 = 原始值[属性];
                    if (typeof 目标方法 === 'function') {
                        return (...参数) => {
                            try {
                                const 执行结果 = 目标方法.apply(原始值, 参数);

                                if (执行结果 && typeof 执行结果.then === 'function') {
                                    const 异步包装器 = 执行结果.then(异步结果 => {
                                        if (异步结果 && typeof 异步结果.then === 'function') {
                                            return 异步结果.then(最终结果 => {
                                                当前值 = 最终结果;
                                                return 代理执行接口;
                                            });
                                        }
                                        当前值 = 异步结果;
                                        return 代理执行接口;
                                    });

                                    return new Proxy(异步包装器, {
                                        get(目标, 新属性) {
                                            // 处理原生Promise方法
                                            if (新属性 === 'then' || 新属性 === 'catch' || 新属性 === 'finally') {
                                                return (...新参数) => {
                                                    const 新Promise = 目标[新属性](...新参数);
                                                    return new Proxy(新Promise, this);
                                                };
                                            }

                                            // 处理值属性
                                            if (新属性 === '值') {
                                                return 目标;
                                            }

                                            // 处理其他方法调用
                                            return (...新参数) => {
                                                return new Proxy(
                                                    目标.then(结果 => {
                                                        if (工具.是串链器(结果)) {
                                                            return 结果[新属性](...新参数);
                                                        }
                                                        当前值 = 结果;
                                                        return 代理执行接口[新属性](...新参数);
                                                    }),
                                                    this
                                                );
                                            };
                                        }
                                    });
                                }

                                当前值 = 执行结果;
                                return 代理执行接口;
                            } catch (错误) {
                                return 扩展管理器.执行钩子('错误处理', 错误, {
                                    方法名: 属性,
                                    当前值,
                                    参数,
                                    代理接口: 代理执行接口
                                });
                            }
                        };
                    }
                }

                throw new Error(`未定义的态射: ${属性}`);
            }
        });

        代理执行接口 = 代理;
        return 代理执行接口;
    };

    // 扩展添加扩展管理能力
    主函数.扩展 = {
        安装: (扩展定义, 配置 = {}) => {
            // 检查扩展定义是否有效
            if (!扩展定义 || typeof 扩展定义 !== 'object') {
                throw new Error(`无效的扩展定义: ${扩展定义}`);
            }

            if (!扩展定义.ID || typeof 扩展定义.ID !== 'string') {
                throw new Error('扩展定义必须包含字符串类型的ID');
            }

            if (!扩展定义.初始化 || typeof 扩展定义.初始化 !== 'function') {
                throw new Error(`扩展 ${扩展定义.ID} 没有提供有效的初始化方法`);
            }

            // 检查扩展依赖
            if (配置.依赖) {
                for (const 依赖项 of [].concat(配置.依赖)) {
                    if (!扩展管理器.获取扩展信息(依赖项)) {
                        throw new Error(`扩展 ${扩展定义.ID} 依赖的扩展 ${依赖项} 未安装`);
                    }
                }
            }

            扩展管理器.安装扩展(扩展定义.ID, 配置);
            扩展定义.初始化(扩展管理器, 定义接口, 全局态射表, 命名空间态射表, 配置);
            return 主函数;
        },
        卸载: (扩展ID) => {
            扩展管理器.卸载扩展(扩展ID);
            return 主函数;
        },
        列表: () => 扩展管理器.获取所有扩展(),
        获取信息: (扩展ID) => 扩展管理器.获取扩展信息(扩展ID)
    };

    return new Proxy(主函数, {
        get(目标, 属性) {
            if (typeof 属性 === 'symbol') {
                if (属性 === 串链器标记) return true;
                return undefined;
            }

            if (属性 === 'prototype' || 属性 === 'length' || 属性 === 'name' ||
                属性 === '扩展' || 属性 === '分支路径选择') {
                return 目标[属性];
            }
            return 定义接口[属性];
        }
    });
};

export { 创建串链器, 创建扩展定义 };


