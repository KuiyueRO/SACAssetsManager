// 代数基础结构
const 代数 = {
  // 幺半群 - 处理方法的组合
  创建幺半群: (组合运算, 单位元) => ({
    组合: 组合运算,
    单位元: () => 单位元,
    结合: (a, b, c) => 组合运算(组合运算(a, b), c)
  }),

  // 范畴 - 处理方法的映射关系
  创建范畴: () => {
    const 态射表 = new Map();
    
    return {
      态射表,
      注册态射: (源, 目标, 映射) => {
        if (!态射表.has(源)) 态射表.set(源, new Map());
        态射表.get(源).set(目标, 映射);
      },
      组合态射: (f, g) => x => f(g(x)),
      恒等态射: x => x
    };
  }
};

// 串链器核心
const 创建串链器 = () => {
  // 全局方法表
  const 全局方法表 = new Map();
  
  // 创建定义接口
  const 创建定义接口 = () => {
    const 定义器 = {
      // 基础方法定义
      方法(名称, 实现或对象, 匹配器) {
        if (!全局方法表.has(名称)) {
          全局方法表.set(名称, []);
        }

        const 方法定义 = {
          实现: typeof 实现或对象 === 'function' 
            ? (当前值, ...参数) => 实现或对象(当前值, ...参数)
            : (当前值, ...参数) => {
                // 如果是对象，将当前值作为this上下文
                const 上下文 = {};
                // 复制所有方法到上下文并注册到全局方法表
                Object.entries(实现或对象).forEach(([键, 值]) => {
                  上下文[键] = typeof 值 === 'function' 
                    ? 值.bind(当前值)
                    : 值;
                  
                  // 将对象中的方法也注册到全局方法表
                  if (typeof 值 === 'function' && !全局方法表.has(键)) {
                    全局方法表.set(键, [{
                      实现: (ctx, ...args) => 值.apply(ctx, args),
                      匹配器: () => true
                    }]);
                  }
                });
                return Object.assign(当前值, 上下文);
              },
          匹配器: 匹配器 || (() => true)
        };

        全局方法表.get(名称).push(方法定义);
        return 定义器代理;
      },

      // 转换方法
      _(目标上下文, 目标名称, 转换实现, 匹配器) {
        const 转换方法名 = `_${目标名称}_`;
        
        this.方法(转换方法名, (源值, ...参数) => {
          const 转换结果 = 转换实现(源值, ...参数);
          return 目标上下文(转换结果);
        }, 匹配器);

        return 定义器代理;
      }
    };

    // 创建定义器代理
    const 定义器代理 = new Proxy(定义器, {
      get(目标, 属性) {
        if (属性 in 目标) {
          return 目标[属性];
        }
        return (实现, 匹配器) => 目标.方法(属性, 实现, 匹配器);
      }
    });

    return 定义器代理;
  };

  // 创建执行接口
  const 创建执行接口 = (初始值) => {
    let 当前值 = 初始值;

    const 代理执行接口 = new Proxy({}, {
      get(目标, 属性) {
        if (属性 === '值') {
          return 当前值;
        }

        if (全局方法表.has(属性)) {
          return (...参数) => {
            const 方法列表 = 全局方法表.get(属性);
            const 匹配方法 = 方法列表.find(方法 => 方法.匹配器(参数));
            
            if (!匹配方法) {
              throw new Error(`未找到匹配的方法实现: ${属性}`);
            }

            当前值 = 匹配方法.实现(当前值, ...参数);
            return 代理执行接口;
          };
        }

        // 如果属性存在于当前值中（对象方法），则返回绑定到当前值的方法
        if (当前值 && typeof 当前值[属性] === 'function') {
          return (...参数) => {
            当前值[属性].apply(当前值, 参数);
            return 代理执行接口;
          };
        }

        throw new Error(`未定义的方法: ${属性}`);
      }
    });

    return 代理执行接口;
  };

  // 创建主函数和定义接口
  const 主函数 = (初始值) => 创建执行接口(初始值);
  const 定义接口 = 创建定义接口();
  
  // 返回代理包装的主函数
  return new Proxy(主函数, {
    get(目标, 属性) {
      if (属性 === 'prototype' || 属性 === 'length' || 属性 === 'name') {
        return 目标[属性];
      }
      return 定义接口[属性];
    }
  });
};

export { 创建串链器 };
