# 中间件层 (Middlewares)

本目录包含项目的中间件组件，提供各种处理流程中的中间层功能。

## 目录结构

- `request/` - 请求中间件，处理API请求相关流程
- `auth/` - 认证中间件，处理用户认证和授权
- `logger/` - 日志中间件，提供统一的日志记录功能
- `cache/` - 缓存中间件，提供数据缓存能力
- `error/` - 错误处理中间件，统一处理错误
- `format/` - 格式化中间件，处理数据格式转换
- `validation/` - 验证中间件，处理数据验证逻辑

## 中间件设计原则

1. **单一职责**：
   - 每个中间件只处理特定类型的任务
   - 避免中间件功能过于复杂
   - 保持中间件简洁明了

2. **可组合性**：
   - 中间件可以自由组合形成处理链
   - 不同组合应对不同处理场景
   - 中间件顺序应清晰可控

3. **透明性**：
   - 中间件不应改变原始数据的结构
   - 处理过程对调用方透明
   - 提供清晰的错误和状态信息

4. **可扩展性**：
   - 易于添加新的中间件
   - 支持自定义中间件
   - 保持中间件框架的开放性

## 中间件接口

所有中间件遵循统一的接口设计：

```js
/**
 * 中间件函数
 * @param {Object} 上下文 - 请求/处理上下文
 * @param {Function} 下一个 - 调用下一个中间件的函数
 * @returns {Promise} - 处理结果的Promise
 */
async function 中间件示例(上下文, 下一个) {
  // 前置处理
  console.log('处理前', 上下文);
  
  try {
    // 调用下一个中间件
    const 结果 = await 下一个(上下文);
    
    // 后置处理
    console.log('处理后', 结果);
    
    return 结果;
  } catch (错误) {
    // 错误处理
    console.error('中间件错误', 错误);
    throw 错误;
  }
}
```

## 中间件应用

中间件可以通过中间件管理器应用到处理流程中：

```js
// 创建中间件管理器
const 管理器 = 创建中间件管理器();

// 添加中间件
管理器.使用(日志中间件);
管理器.使用(认证中间件);
管理器.使用(缓存中间件);
管理器.使用(格式化中间件);

// 处理请求
const 结果 = await 管理器.处理(请求上下文);
```

## 常用中间件

### 请求中间件

处理HTTP请求和响应：

```js
import { 请求中间件 } from '../middlewares/request/requestMiddleware.js';

// 使用请求中间件
管理器.使用(请求中间件({
  超时: 30000,
  重试: 3,
  基础URL: 'https://api.example.com'
}));
```

### 缓存中间件

提供数据缓存能力：

```js
import { 缓存中间件 } from '../middlewares/cache/cacheMiddleware.js';

// 使用缓存中间件
管理器.使用(缓存中间件({
  过期时间: 3600,
  存储器: '内存',
  键生成器: (上下文) => `${上下文.方法}:${上下文.路径}`
}));
```

### 错误处理中间件

统一处理错误：

```js
import { 错误处理中间件 } from '../middlewares/error/errorMiddleware.js';

// 使用错误处理中间件
管理器.使用(错误处理中间件({
  日志级别: '错误',
  包装错误: true,
  重试策略: '指数退避'
}));
```

## 创建自定义中间件

创建自定义中间件的示例：

```js
/**
 * 创建性能监控中间件
 * @param {Object} 选项 - 中间件选项
 * @returns {Function} - 中间件函数
 */
function 创建性能监控中间件(选项 = {}) {
  const { 阈值 = 100, 记录器 = console } = 选项;
  
  return async function 性能监控中间件(上下文, 下一个) {
    const 开始时间 = Date.now();
    
    try {
      // 调用下一个中间件
      const 结果 = await 下一个(上下文);
      
      const 耗时 = Date.now() - 开始时间;
      if (耗时 > 阈值) {
        记录器.warn(`[性能] ${上下文.路径} 耗时 ${耗时}ms 超过阈值 ${阈值}ms`);
      }
      
      return 结果;
    } catch (错误) {
      const 耗时 = Date.now() - 开始时间;
      记录器.error(`[性能] ${上下文.路径} 出错，耗时 ${耗时}ms`, 错误);
      throw 错误;
    }
  };
}
```

## 注意事项

- 中间件应该是无状态的，或者状态应该是隔离的
- 中间件的执行顺序很重要，需要仔细设计
- 中间件应该处理好自己的异常，不中断整个处理链
- 避免在中间件中执行耗时的同步操作，影响性能
- 中间件链中的数据修改应该是可预期和可控的 