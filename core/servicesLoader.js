/**
 * 模块加载器 - 核心模块
 * 
 * 作为系统的引导程序，负责：
 * - 加载所有核心模块
 * - 管理模块生命周期
 * - 协调模块之间的依赖关系
 * - 提供模块注册和查询机制
 * - 解构并转换宿主API为模块层API
 * 
 * 模块的定义:
 * 模块将随宿主环境启动和关闭
 * 模块并不是网络模块,而是内部基础特性供应者
 * 所有模块配合向扩展提供以下特性
 * - 扩展加载和生命周期管理
 * - 扩展所需的UI扩展点
 * - 提供给扩展使用的工具包(toolBox)
 * - 窗口内不同扩展通信
 * - electron环境下的node接口暴露和nodeModules支持
 * - 浏览器环境(包含electron)环境下的跨窗口通信
 * - 日志和代码编译
 * - 配置存储
 * 
 * 加载机制要求:
 * - 部分模块渐进增强,例如加载日志模块后,日志由日志模块提供,否则由console提供
 * - 事件模块加载后,事件由事件模块提供,否则宿主API提供
 * - 配置模块加载后,配置保存才能生效
 * - 需要注意模块加载顺序,例如事件模块必须在日志模块之前加载,否则日志模块无法正常工作
 * - 扩展加载器模块最后加载,此时所有模块已经加载完成,扩展加载器可以进行扩展的加载
 * - 扩展也可以注册用户态服务,例如用户态的配置服务,用户态的事件服务,用户态的日志服务等
 * - 扩展注册的服务只能使用两种方式:
 *    1.worker线程
 *    2.electron环境下使用独立窗口
 * - 扩展注册的服务与扩展之间的具体通信由扩展自行处理,模块加载器不负责通信,只负责提供环境和启动以及基础的通信机制 
 * - 扩展的特点:
 *    除非注册服务,否则扩展全部是****无状态的****(UI状态不在此列),尽可能设计为命令集合 
 * 
 * 核心模块**不是**扩展,而是内部模块
 * 
 * @AI 文件名使用英文,内部函数等使用中文,注意语义化,除非极其必要禁止使用类,请仔细判断目前的模块列表是否完备
 */



/**
 * 这个区段临时用于测试
 */
import './test.js';


// 模块注册表和状态管理
const 模块注册表 = new Map();
const 模块名称集合 = new Set();
let 宿主API = null;
let 已初始化 = false;

// 核心模块加载顺序（依赖优先）
const 核心模块列表 = [
  // === 基础层 ===
  "环境模块",        // 提供宿主环境信息，依赖宿主层
  "事件总线模块",    // 最基础的通信机制，其他模块都依赖它
  "路由模块",        // 提供路由能力，依赖事件总线
  "日志模块",        // 基础日志能力，依赖事件总线
  "错误处理模块",    // 统一的错误处理，依赖日志
  "工具箱模块",      // 提供通用工具函数，依赖日志

  // === 系统层 ===
  "存储模块",        // 本地数据持久化，依赖错误处理
  "配置模块",        // 配置管理，依赖存储
  "进程通信模块",    // 跨进程通信，依赖事件总线和路由
  "安全模块",        // 权限控制、加密解密，依赖配置
  
  // === 应用层 ===
  
  "窗口管理模块",    // 窗口生命周期，依赖进程通信
  "UI模块",          // UI框架和组件注册，依赖窗口管理
  "主题模块",        // 主题管理，依赖UI模块
  

  // === 扩展层 ===
  "扩展加载模块"     // 扩展系统，依赖所有基础模块
];


// 简化模块状态枚举
const 模块状态 = {
  未加载: 'UNLOADED',
  已加载: 'LOADED',
  错误: 'ERROR'
};

// 简化默认配置
const 默认模块配置 = {
  重试次数: 3,
  重试延迟: 1000,
  超时时间: 5000
};

// 简化模块信息创建
const 创建模块信息 = (名称, 实例, 配置 = {}) => {
  const 合并后配置 = 合并配置(默认模块配置, 配置);
  
  return {
    名称,
    实例,
    配置: 合并后配置,
    状态: 模块状态.已加载,
    错误: null,
    设置状态(新状态, 错误 = null) {
      this.状态 = 新状态;
      this.错误 = 错误;
      console.info(`模块 [${this.名称}] 状态更新为: ${新状态}${错误 ? ` (错误: ${错误.message})` : ''}`);
    }
  };
};

/**
 * 深度合并配置
 * @param {Object} 默认值 
 * @param {Object} 自定义值 
 */
function 合并配置(默认值, 自定义值) {
  const 结果 = { ...默认值 };
  
  for (const 键 in 自定义值) {
    if (typeof 自定义值[键] === 'object' && 自定义值[键] !== null) {
      结果[键] = 合并配置(结果[键] || {}, 自定义值[键]);
    } else {
      结果[键] = 自定义值[键];
    }
  }
  
  return 结果;
}

/**
 * 初始化模块加载器
 * @param {Object} 提供的宿主API - 插件主体提供的API对象
 */
export async function 初始化(提供的宿主API) {
  if (已初始化) {
    console.warn("模块加载器已经初始化，忽略重复调用");
    return;
  }
  
  宿主API = 提供的宿主API;
  console.info("模块加载器初始化中...");
  
  // 注册模块加载器自身作为一个模块
  注册模块("模块加载器", {
    获取模块,
    注册模块,
    获取所有模块名称: () => Array.from(模块名称集合),
    获取宿主API: () => 宿主API
  });
  
  已初始化 = true;
  console.info("模块加载器初始化完成");
}

/**
 * 启动所有模块
 */
export async function 启动() {
  if (!已初始化) {
    throw new Error("模块加载器尚未初始化");
  }
  
  console.info("开始加载核心模块...");
  
  try {
    // 按顺序加载所有核心模块
    for (const 模块名称 of 核心模块列表) {
      await 加载模块(模块名称);
    }
    
    console.info("所有核心模块加载完成");
  } catch (错误) {
    console.error("模块加载失败:", 错误);
    throw 错误;
  }
}

/**
 * 销毁所有模块
 */
export async function 销毁() {
  if (!已初始化) return;
  
  console.info("开始清理模块...");
  
  模块注册表.clear();
  模块名称集合.clear();
  宿主API = null;
  已初始化 = false;
  
  console.info("模块清理完成");
}

/**
 * 注册模块到模块注册表
 * @param {string} 模块名称 - 模块的唯一标识名称
 * @param {Object} 模块实例 - 模块对象实例
 * @returns {boolean} 是否注册成功
 */
export function 注册模块(模块名称, 模块实例) {
  if (模块注册表.has(模块名称)) {
    console.warn(`模块 [${模块名称}] 已存在，将被覆盖`);
    // 确保旧模块被正确清理
    const 旧模块 = 模块注册表.get(模块名称);
    if (typeof 旧模块.实例.销毁 === 'function') {
      try {
        旧模块.实例.销毁();
      } catch (错误) {
        console.error(`清理旧模块 [${模块名称}] 时发生错误:`, 错误);
      }
    }
  }
  
  const 模块元数据 = 创建模块信息(模块名称, 模块实例);
  模块注册表.set(模块名称, 模块元数据);
  模块名称集合.add(模块名称);
  console.info(`模块 [${模块名称}] 已注册`);
  return true;
}

/**
 * 获取已注册的模块
 * @param {string} 模块名称 - 要获取的模块名称
 * @returns {Object|null} 模块实例或null（如果模块不存在）
 */
export function 获取模块(模块名称) {
  const 模块 = 模块注册表.get(模块名称);
  if (!模块) {
    console.warn(`尝试获取不存在的模块: [${模块名称}]`);
    return null;
  }
  
  return 模块.实例;
}

/**
 * 获取模块状态
 * @param {string} 模块名称 - 模块名称
 * @returns {string} 模块状态
 */
export function 获取模块状态(模块名称) {
  if (!模块注册表.has(模块名称)) {
    return 模块状态.未加载;
  }
  return 模块注册表.get(模块名称).状态;
}

/**
 * 加载单个模块
 * @param {string} 模块名称 - 模块名称
 * @param {Object} 配置 - 模块配置
 * @returns {Promise<模块信息>}
 */
async function 加载模块(模块名称, 配置 = {}) {
  console.info(`正在加载模块 [${模块名称}]...`);
  
  let 当前重试次数 = 配置.重试次数 || 3;
  let 最后错误 = null;

  while (当前重试次数 >= 0) {
    try {
      // 检查模块是否已存在
      if (模块注册表.has(模块名称)) {
        return 模块注册表.get(模块名称);
      }

      const 模块路径 = `core/services/${模块名称}.js`;
      const 完整路径 = 宿主API.解析路径(模块路径);
      
      // 动态导入模块
      const 模块模块 = await import(完整路径);
      const 创建模块 = 模块模块.创建模块 || 模块模块.default;
      
      if (typeof 创建模块 !== 'function') {
        throw new Error(`模块 [${模块名称}] 没有导出创建模块函数`);
      }
      
      // 创建并注册模块实例
      const 模块实例 = await 创建模块(配置);
      const 模块元数据 = 创建模块信息(模块名称, 模块实例, 配置);
      
      模块注册表.set(模块名称, 模块元数据);
      模块名称集合.add(模块名称);
      
      console.info(`模块 [${模块名称}] 加载完成`);
      return 模块元数据;

    } catch (错误) {
      最后错误 = 错误;
      console.error(`加载模块 [${模块名称}] 失败 (剩余重试次数: ${当前重试次数}):`, 错误);
      
      if (当前重试次数 > 0) {
        await new Promise(resolve => setTimeout(resolve, 配置.重试延迟 || 1000));
        当前重试次数--;
        continue;
      }
      
      throw new Error(`无法加载模块 [${模块名称}]: ${最后错误.message}`);
    }
  }
}


