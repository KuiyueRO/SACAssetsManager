// 串链器测试用例.js
import { 创建串链器, 创建扩展定义 } from '../src/工具箱/forCore/串链器.js';

// 简单断言实现
const 断言 = {
  相等(实际值, 期望值, 消息 = '') {
    if (实际值 !== 期望值) {
      throw new Error(`断言失败: ${消息}\n期望值: ${期望值}\n实际值: ${实际值}`);
    }
    console.log(`✓ ${消息}`);
  },
  
  为真(条件, 消息 = '') {
    if (!条件) {
      throw new Error(`断言失败: ${消息}`);
    }
    console.log(`✓ ${消息}`);
  }
};

// 记录调用顺序用于验证
let 调用记录 = [];

// 测试1: 无匹配器重载
console.log('\n测试1: 无匹配器重载');
const 数学链 = 创建串链器();

数学链
  .命名空间('数学')
    .加((值, 加数) => {
      调用记录.push('基础加法');
      return 值 + 加数;
    })
    .加((值, 加数) => {
      调用记录.push('加倍加法');
      return 值 + 加数 * 2;
    });

const 结果1 = 数学链(10).使用命名空间('数学').加(5).值;
断言.相等(结果1, 20, '无匹配器重载时应使用后注册的实现');
断言.相等(调用记录[0], '加倍加法', '应该调用后注册的加倍加法');

// 重置调用记录
调用记录 = [];

// 测试2: 复杂匹配器重载
console.log('\n测试2: 复杂匹配器重载');
const 数学链2 = 创建串链器();

const 是大数 = ([数]) => typeof 数 === 'number' && 数 > 100;
const 是小数 = ([数]) => typeof 数 === 'number' && !Number.isInteger(数);
const 是负数 = ([数]) => typeof 数 === 'number' && 数 < 0;
const 是字符串 = ([数]) => typeof 数 === 'string';

数学链2
  .命名空间('数学')
    .加((值, 加数) => {
      调用记录.push('基础加法');
      return 值 + 加数;
    })
    .加((值, 加数) => {
      调用记录.push('大数加倍');
      return 值 + 加数 * 2;
    }, 是大数)
    .加((值, 加数) => {
      调用记录.push('小数取整');
      return 值 + Math.floor(加数);
    }, 是小数)
    .加((值, 加数) => {
      调用记录.push('负数取反');
      return 值 - 加数;
    }, 是负数)
    .加((值, 加数) => {
      调用记录.push('字符串转换');
      return 值 + Number(加数);
    }, 是字符串)
    .加((值, 加数) => {
      调用记录.push('最新普通加法');
      return 值 + 加数 + 1;
    });

// 测试各种情况
const 普通结果 = 数学链2(10).使用命名空间('数学').加(5).值;
断言.相等(普通结果, 16, '普通数字应使用最新注册的无匹配器实现');
断言.相等(调用记录[0], '最新普通加法', '应该调用最新注册的普通加法');

const 大数结果 = 数学链2(10).使用命名空间('数学').加(200).值;
断言.相等(大数结果, 410, '大数应使用专门的大数处理实现');
断言.相等(调用记录[1], '大数加倍', '大数时应该调用大数加倍实现');

const 小数结果 = 数学链2(10).使用命名空间('数学').加(5.7).值;
断言.相等(小数结果, 15, '小数应使用取整实现');
断言.相等(调用记录[2], '小数取整', '小数时应该调用小数取整实现');

const 负数结果 = 数学链2(10).使用命名空间('数学').加(-5).值;
断言.相等(负数结果, 15, '负数应使用取反实现');
断言.相等(调用记录[3], '负数取反', '负数时应该调用负数取反实现');

const 字符串结果 = 数学链2(10).使用命名空间('数学').加("5").值;
断言.相等(字符串结果, 15, '字符串应使用转换实现');
断言.相等(调用记录[4], '字符串转换', '字符串时应该调用字符串转换实现');

// 测试3: 匹配器优先级
console.log('\n测试3: 匹配器优先级');
调用记录 = [];

const 数学链3 = 创建串链器();
const 是数字 = ([数]) => typeof 数 === 'number';

数学链3
  .命名空间('数学')
    .加((值, 加数) => {
      调用记录.push('基础加法');
      return 值 + 加数;
    })
    .加((值, 加数) => {
      调用记录.push('数字处理');
      return 值 + 加数 * 2;
    }, 是数字)
    .加((值, 加数) => {
      调用记录.push('大数处理');
      return 值 + 加数 * 3;
    }, 是大数);

const 普通数字结果 = 数学链3(10).使用命名空间('数学').加(5).值;
断言.相等(普通数字结果, 20, '普通数字应匹配通用数字处理');
断言.相等(调用记录[0], '数字处理', '应该调用数字处理实现');

const 大数结果2 = 数学链3(10).使用命名空间('数学').加(200).值;
断言.相等(大数结果2, 610, '大数应匹配专门的大数处理');
console.log(调用记录);
断言.相等(调用记录[1], '大数处理', '应该调用大数处理实现');

console.log('\n所有测试完成 ✨');