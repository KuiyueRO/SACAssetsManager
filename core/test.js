import { 创建串链器 } from '../src/工具箱/forCore/串链器.js';

// 创建测试用串链器
const 测试串链器 = 创建串链器();

// 基础功能测试
function 测试基础功能() {
  console.log('----- 开始基础功能测试 -----');
  
  // 定义基本态射
  测试串链器
    .加((值, 增量 = 1) => 值 + 增量)
    .减((值, 减量 = 1) => 值 - 减量)
    .乘((值, 倍数 = 2) => 值 * 倍数)
    .除((值, 除数 = 2) => 值 / 除数)
    .平方((值) => 值 * 值)
    .取绝对值((值) => Math.abs(值))
    .四舍五入((值) => Math.round(值))
    .转字符串((值) => String(值));
  
  // 测试链式调用
  const 结果1 = 测试串链器(10).加(5).乘(2).减(3).值;
  console.log('链式计算结果1:', 结果1, 结果1 === 27 ? '✓' : '✗');
  
  // 测试多参数调用
  const 结果2 = 测试串链器(100).除(4).加(10).乘(3).值;
  console.log('链式计算结果2:', 结果2, 结果2 === 105 ? '✓' : '✗');
  
  // 测试复杂嵌套调用
  const 结果3 = 测试串链器(5).加(测试串链器(3).加(2).值).乘(2).值;
  console.log('链式嵌套结果3:', 结果3, 结果3 === 20 ? '✓' : '✗');
  
  console.log('----- 基础功能测试完成 -----\n');
}

// 命名空间功能测试
function 测试命名空间功能() {
  console.log('----- 开始命名空间功能测试 -----');
  
  // 定义文本处理命名空间
  测试串链器
    .命名空间('文本')
      .大写((文本) => 文本.toUpperCase())
      .小写((文本) => 文本.toLowerCase())
      .首字母大写((文本) => 文本.charAt(0).toUpperCase() + 文本.slice(1))
      .计数((文本) => 文本.length)
      .分割((文本, 分隔符 = '') => 文本.split(分隔符))
      .连接((数组, 连接符 = '') => 数组.join(连接符))
    .退出命名空间();
  
  // 测试命名空间调用
  const 文本结果1 = 测试串链器('hello world')
    .使用命名空间('文本')
    .大写()
    .值;
  console.log('命名空间文本处理1:', 文本结果1, 文本结果1 === 'HELLO WORLD' ? '✓' : '✗');
  
  const 文本结果2 = 测试串链器('HELLO WORLD')
    .使用命名空间('文本')
    .小写()
    .分割(' ')
    .退出命名空间()
    .值;
  console.log('命名空间文本处理2:', 文本结果2, 
    Array.isArray(文本结果2) && 文本结果2.join(',') === 'hello,world' ? '✓' : '✗');
  
  // 测试在命名空间和全局态射间切换
  const 混合结果 = 测试串链器(5)
    .加(10)
    .使用命名空间('文本')
    .转字符串()  // 假设这个方法同样在文本命名空间中定义
    .首字母大写()
    .退出命名空间()
    .值;
  
  // 注册转字符串方法到文本命名空间
  测试串链器.命名空间('文本').转字符串((值) => String(值)).退出命名空间();
  
  // 重新测试
  const 混合结果2 = 测试串链器(5)
    .加(10)
    .使用命名空间('文本')
    .转字符串()
    .首字母大写()
    .退出命名空间()
    .值;
  
  console.log('命名空间混合调用:', 混合结果2, 混合结果2 === '15' ? '✓' : '✗');
  
  console.log('----- 命名空间功能测试完成 -----\n');
}

// 条件分支测试
function 测试条件分支() {
  console.log('----- 开始条件分支测试 -----');
  // 使用分支API进行条件判断
  const 正数处理 = 测试串链器(10)
    .分支({
      '正数': (值) => 测试串链器(值).加(5).乘(2),
      '零': (值) => 测试串链器(0),
      '负数': (值) => 测试串链器(值).乘(-1)
    })
    .值;
  console.log('正数分支处理:', 正数处理, 正数处理 === 30 ? '✓' : '✗');
  
  const 负数处理 = 测试串链器(-5)
    .分支({
      '正数': (值) => 测试串链器(值).加(5).乘(2),
      '零': (值) => 测试串链器(0),
      '负数': (值) => 测试串链器(值).乘(-1).加(10)
    }, (值) => 测试串链器(值)) // 默认分支
    .值;
  console.log('负数分支处理:', 负数处理, 负数处理 === -5 ? '✓' : '✗');
  
  // 定义辅助函数以支持分支条件
  测试串链器.分支路径选择 = (条件映射) => (当前值) => {
    if (条件映射.正数 && 当前值 > 0) return '正数';
    if (条件映射.零 && 当前值 === 0) return '零';
    if (条件映射.负数 && 当前值 < 0) return '负数';
    return '默认';
  };
  
  // 现在尝试使用辅助函数
  const 重新处理 = 测试串链器(-7)
    .分支({
      '正数': (值) => 测试串链器(值).加(5).乘(2),
      '零': (值) => 测试串链器(0),
      '负数': (值) => 测试串链器(值).取绝对值().加(3)
    })
    .值;
  
  console.log('分支重新处理:', 重新处理);
  
  console.log('----- 条件分支测试完成 -----\n');
}

// 错误处理测试
function 测试错误处理() {
  console.log('----- 开始错误处理测试 -----');
  
  // 定义可能引发错误的态射
  测试串链器
    .可能出错((值) => {
      if (typeof 值 !== 'number') {
        throw new Error('输入必须是数字');
      }
      return 值 * 2;
    })
    .除以零((值) => 值 / 0);
  
  // 测试正常情况
  try {
    const 正常结果 = 测试串链器(10).可能出错().值;
    console.log('正常调用结果:', 正常结果, 正常结果 === 20 ? '✓' : '✗');
  } catch (错误) {
    console.error('正常调用出错:', 错误.message);
  }
  
  // 测试错误情况
  try {
    const 错误结果 = 测试串链器('不是数字').可能出错().值;
    console.log('错误调用结果:', 错误结果);
  } catch (错误) {
    console.log('预期的错误被捕获:', 错误.message, 错误.message.includes('输入必须是数字') ? '✓' : '✗');
  }
  
  // 测试除以零错误
  try {
    const 除零结果 = 测试串链器(10).除以零().值;
    console.log('除以零结果:', 除零结果);
  } catch (错误) {
    console.log('除以零错误:', 错误.message);
  }
  
  console.log('----- 错误处理测试完成 -----\n');
}

// 原生方法集成测试
function 测试原生方法集成() {
  console.log('----- 开始原生方法集成测试 -----');
  
  // 测试数组原生方法
  const 数组测试 = 测试串链器([1, 2, 3, 4, 5])
    .map(item => item * 2)
    .filter(item => item > 5)
    .reduce((acc, cur) => acc + cur, 0)
    .值;
  console.log('数组原生方法测试:', 数组测试, 数组测试 === 18 ? '✓' : '✗');
  
  // 测试字符串原生方法
  const 字符串测试 = 测试串链器('  hello world  ')
    .trim()
    .split(' ')
    .join('-')
    .toUpperCase()
    .值;
  console.log('字符串原生方法测试:', 字符串测试, 字符串测试 === 'HELLO-WORLD' ? '✓' : '✗');
  
  console.log('----- 原生方法集成测试完成 -----\n');
}

// 异步方法支持测试
async function 测试异步支持() {
  console.log('----- 开始异步支持测试 -----');
  
  // 定义异步态射
  测试串链器
    .延迟加((值, 增量 = 1) => {
      return new Promise(resolve => {
        setTimeout(() => resolve(值 + 增量), 100);
      });
    })
    .延迟乘((值, 倍数 = 2) => {
      return new Promise(resolve => {
        setTimeout(() => resolve(值 * 倍数), 100);
      });
    });
  
  // 测试单个异步方法
  const 异步结果1 = await 测试串链器(5).延迟加(3);
  console.log('单个异步方法结果:', 异步结果1, 异步结果1 === 8 ? '✓' : '✗');
  
  // 测试链式异步方法
  const 异步包装器 = 测试串链器(5).延迟加(3).链().延迟乘(2);
  const 异步结果2 = await 异步包装器;
  console.log('链式异步方法结果:', 异步结果2.值, 异步结果2.值 === 16 ? '✓' : '✗');
  
  console.log('----- 异步支持测试完成 -----\n');
}

// 运行所有测试
async function 运行测试() {
  console.log('======= 串链器基础功能测试开始 =======');
  
  测试基础功能();
  测试命名空间功能();
  测试条件分支();
  测试错误处理();
  测试原生方法集成();
  await 测试异步支持();
  
  console.log('======= 串链器基础功能测试完成 =======');
}

运行测试();
