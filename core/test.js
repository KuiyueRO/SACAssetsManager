  /* 
   * 注意: 以下测试已经通过，被注释掉
   * - 测试1: 基本分支功能
   * - 测试2: 默认分支功能
   * - 测试3: 链式调用测试
   * - 测试4: 自定义分支选择
   * - 测试5: 嵌套分支功能
   * - 测试6: 类型分支功能
   * - 测试7: 复杂条件分支功能
   * - 测试8: 多层分支组合功能
   */
import { 创建串链器 } from '../src/工具箱/forCore/串链器.js';

/**
 * 全面测试串链器分支功能
 * 测试设计确保即使出错也能继续执行并生成完整报告
 */
function 测试串链器分支功能() {
  console.log('\n========== 串链器分支功能全面测试 ==========');
  
  // 测试报告对象
  const 测试报告 = {
    总测试数: 0,
    通过数: 0,
    失败数: 0,
    错误: [],
    结果: {}
  };
  
  // 测试运行器 - 确保每个测试都能独立运行且不影响其他测试
  function 运行测试(测试名称, 测试函数) {
    测试报告.总测试数++;
    console.log(`\n>> 运行测试: ${测试名称}`);
    
    try {
      const 结果 = 测试函数();
      测试报告.通过数++;
      测试报告.结果[测试名称] = { 状态: '通过', 输出: 结果 };
      console.log(`✓ 测试通过: ${测试名称}`);
      return 结果;
    } catch (错误) {
      测试报告.失败数++;
      测试报告.错误.push({ 测试名称, 错误 });
      测试报告.结果[测试名称] = { 状态: '失败', 错误: 错误.message };
      console.error(`✗ 测试失败: ${测试名称}`);
      console.error(`  错误: ${错误.message}`);
      return null;
    }
  }
  
  // 断言工具
  const 断言 = {
    相等(实际值, 期望值, 消息) {
      if (实际值 !== 期望值) {
        throw new Error(`${消息}: 期望 ${期望值}，实际 ${实际值}`);
      }
      return true;
    },
    
    真值(值, 消息) {
      if (!值) {
        throw new Error(`${消息}: 期望为真，实际为 ${值}`);
      }
      return true;
    },
    
    假值(值, 消息) {
      if (值) {
        throw new Error(`${消息}: 期望为假，实际为 ${值}`);
      }
      return true;
    },
    
    包含(对象, 属性, 消息) {
      if (!(属性 in 对象)) {
        throw new Error(`${消息}: 对象不包含属性 ${属性}`);
      }
      return true;
    }
  };
  
  // 测试1: 基本分支功能 - 测试正数/负数/零分支
  运行测试('基本分支功能', () => {
    const 串链 = 创建串链器();
    
    // 测试正数分支
    const 正数结果 = 串链(10)
      .分支({
        '正数': 值 => 值 * 2,
        '负数': 值 => 值 * -1,
        '零': 值 => 100,
        '默认': 值 => 值
      })
      .值;
      
    断言.相等(正数结果, 20, '正数分支应返回值的2倍');
    
    // 测试负数分支
    const 负数结果 = 串链(-5)
      .分支({
        '正数': 值 => 值 * 2,
        '负数': 值 => 值 * -1,
        '零': 值 => 100,
        '默认': 值 => 值
      })
      .值;
      
    断言.相等(负数结果, 5, '负数分支应返回值的相反数');
    
    // 测试零分支
    const 零结果 = 串链(0)
      .分支({
        '正数': 值 => 值 * 2,
        '负数': 值 => 值 * -1,
        '零': 值 => 100,
        '默认': 值 => 值
      })
      .值;
      
    断言.相等(零结果, 100, '零分支应返回100');
    
    return { 正数结果, 负数结果, 零结果 };
  });
  
  // 测试2: 默认分支功能
  运行测试('默认分支功能', () => {
    const 串链 = 创建串链器();
    
    // 测试默认分支 - 不提供匹配分支
    const 默认结果1 = 串链('字符串')
      .分支({
        '正数': 值 => 值 * 2,
        '负数': 值 => 值 * -1,
        '默认': 值 => `默认: ${值}`
      })
      .值;
      
    断言.相等(默认结果1, '默认: 字符串', '非数字值应进入默认分支');
    
    // 测试仅有默认分支的情况
    const 默认结果2 = 串链(42)
      .分支({
        '默认': 值 => 值 * 2
      })
      .值;
      
    断言.相等(默认结果2, 84, '仅有默认分支时应执行默认分支');
    
    // 测试没有提供默认分支且无匹配情况
    const 默认结果3 = 串链('文本')
      .分支({
        '正数': 值 => 值 * 2,
        '负数': 值 => 值 * -1,
      })
      .值;
      
    断言.相等(默认结果3, '文本', '无匹配且无默认分支时应保持原值');
    
    return { 默认结果1, 默认结果2, 默认结果3 };
  });
  
  // 测试3: 链式调用测试
  运行测试('链式调用测试', () => {
    const 串链 = 创建串链器();
    
    // 测试分支后继续链式调用
    const 链式结果 = 串链(5)
      .分支({
        '正数': 值 => 值 * 2,
        '负数': 值 => 值 * -1,
        '默认': 值 => 值
      })
      .分支({
        '正数': 值 => 值 + 10,
        '默认': 值 => 值
      })
      .值;
      
    断言.相等(链式结果, 20, '链式分支应正确执行并传递值');
    
    return { 链式结果 };
  });
  
  // 测试4: 自定义分支选择器
  运行测试('自定义分支选择器', () => {
    // 创建带有自定义分支路径选择器的串链器
    const 自定义串链 = 创建串链器({
      分支路径选择: (条件映射) => {
        return (值) => {
          // 根据值的类型选择分支
          if (Array.isArray(值)) return '数组';
          if (typeof 值 === 'string') return '字符串';
          if (typeof 值 === 'number') return '数字';
          if (typeof 值 === 'object') return '对象';
          return '默认';
        };
      }
    });
    
    // 测试自定义选择器处理不同类型
    const 字符串结果 = 自定义串链('测试')
      .分支({
        '数组': 值 => '是数组',
        '字符串': 值 => `字符串: ${值}`,
        '数字': 值 => '是数字',
        '对象': 值 => '是对象',
        '默认': 值 => '其它类型'
      })
      .值;
      
    断言.相等(字符串结果, '字符串: 测试', '自定义选择器应正确识别字符串');
    
    const 数组结果 = 自定义串链([1, 2, 3])
      .分支({
        '数组': 值 => `数组长度: ${值.length}`,
        '字符串': 值 => `字符串: ${值}`,
        '数字': 值 => '是数字',
        '对象': 值 => '是对象',
        '默认': 值 => '其它类型'
      })
      .值;
      
    断言.相等(数组结果, '数组长度: 3', '自定义选择器应正确识别数组');
    
    return { 字符串结果, 数组结果 };
  });
  
  // 测试5: 嵌套分支功能
  运行测试('嵌套分支功能', () => {
    const 串链 = 创建串链器();
    
    // 创建用于内部分支的串链实例
    const 内部串链 = 创建串链器();
    
    // 测试在分支内部再次使用分支
    const 嵌套结果 = 串链(15)
      .分支({
        '正数': 值 => 内部串链(值)
          .分支({
            '正数': v => v > 10 ? v * 3 : v * 2,
            '默认': v => v
          })
          .值,
        '负数': 值 => 值 * -1,
        '默认': 值 => 值
      })
      .值;
      
    断言.相等(嵌套结果, 45, '嵌套分支应正确执行并返回结果');
    
    return { 嵌套结果 };
  });
  
  // 测试6: 类型分支功能
  运行测试('类型分支功能', () => {
    // 创建类型判断分支路径选择器
    const 类型串链 = 创建串链器({
      分支路径选择: (条件映射) => {
        return (值) => {
          const 类型 = Object.prototype.toString.call(值).slice(8, -1).toLowerCase();
          // 检查条件映射中是否有对应的类型键
          return 条件映射[类型] ? 类型 : '默认';
        };
      }
    });
    
    // 测试不同类型的分支处理
    const 结果集 = {};
    
    // 测试字符串类型
    结果集.字符串 = 类型串链('测试字符串')
      .分支({
        string: 值 => `字符串长度: ${值.length}`,
        number: 值 => `数值: ${值}`,
        object: 值 => '这是对象',
        array: 值 => '这是数组',
        '默认': 值 => '未知类型'
      })
      .值;
      
    断言.相等(结果集.字符串, '字符串长度: 5', '类型分支应识别字符串');
    
    // 测试数值类型
    结果集.数值 = 类型串链(42)
      .分支({
        string: 值 => `字符串长度: ${值.length}`,
        number: 值 => `数值: ${值}`,
        object: 值 => '这是对象',
        array: 值 => '这是数组',
        '默认': 值 => '未知类型'
      })
      .值;
      
    断言.相等(结果集.数值, '数值: 42', '类型分支应识别数值');
    
    return 结果集;
  });
  
  // 测试7: 复杂条件分支功能
  运行测试('复杂条件分支功能', () => {
    // 创建处理复杂条件的分支路径选择器
    const 条件串链 = 创建串链器({
      分支路径选择: (条件映射) => {
        return (值) => {
          // 根据值的范围决定分支
          if (typeof 值 === 'number') {
            if (值 < 0) return '负数';
            if (值 === 0) return '零';
            if (值 < 10) return '个位数';
            if (值 < 100) return '十位数';
            if (值 < 1000) return '百位数';
            return '大数';
          }
          return '默认';
        };
      }
    });
    
    const 结果集 = {};
    
    // 测试各种数值范围
    结果集.负数 = 条件串链(-5)
      .分支({
        '负数': 值 => `负数: ${值}`,
        '零': 值 => '零值',
        '个位数': 值 => `个位数: ${值}`,
        '十位数': 值 => `十位数: ${值}`,
        '百位数': 值 => `百位数: ${值}`,
        '大数': 值 => `大数: ${值}`,
        '默认': 值 => '非数值'
      })
      .值;
      
    断言.相等(结果集.负数, '负数: -5', '应正确识别负数');
    
    结果集.十位数 = 条件串链(42)
      .分支({
        '负数': 值 => `负数: ${值}`,
        '零': 值 => '零值',
        '个位数': 值 => `个位数: ${值}`,
        '十位数': 值 => `十位数: ${值}`,
        '百位数': 值 => `百位数: ${值}`,
        '大数': 值 => `大数: ${值}`,
        '默认': 值 => '非数值'
      })
      .值;
      
    断言.相等(结果集.十位数, '十位数: 42', '应正确识别十位数');
    
    return 结果集;
  });
  
  // 测试8: 异常处理分支功能
  运行测试('异常处理分支功能', () => {
    const 串链 = 创建串链器();
    
    // 测试分支内抛出异常的情况
    try {
      const 异常结果 = 串链(10)
        .分支({
          '正数': 值 => { throw new Error('分支内故意抛出异常'); },
          '默认': 值 => 值
        })
        .值;
      
      断言.假值(true, '应该抛出异常而不是继续执行');
      return { 错误: '未抛出期望的异常' };
    } catch (错误) {
      断言.真值(错误.message.includes('分支内故意抛出异常'), '应正确传播分支内的异常');
      return { 状态: '正确捕获异常', 信息: 错误.message };
    }
  });
  
  // 测试9: 异步分支功能
  运行测试('异步分支功能', async () => {
    const 串链 = 创建串链器();
    
    // 测试异步分支
    const 异步结果Promise = 串链(15)
      .分支({
        '正数': async 值 => {
          // 模拟异步操作
          return new Promise(resolve => {
            setTimeout(() => resolve(值 * 3), 100);
          });
        },
        '默认': 值 => 值
      });
    
    // 检查是否返回Promise
    断言.真值(异步结果Promise instanceof Promise, '异步分支应返回Promise');
    
    // 等待异步结果
    const 异步结果 = await 异步结果Promise;
    断言.相等(异步结果.值, 45, '异步分支应正确处理并返回结果');
    
    return { 异步结果: 异步结果.值 };
  });
  
  // 测试10: 错误选择器测试
  运行测试('错误选择器测试', () => {
    // 测试非法的分支路径选择器
    const 错误串链 = 创建串链器({
      // 提供一个不符合规范的选择器 - 不返回函数
      分支路径选择: (条件映射) => {
        return '错误返回值'; // 应该返回函数而不是字符串
      }
    });
    
    // 应该使用默认行为而不是崩溃
    const 错误选择结果 = 错误串链(10)
      .分支({
        '正数': 值 => 值 * 2,
        '负数': 值 => 值 * -1,
        '默认': 值 => `默认: ${值}`
      })
      .值;
    
    // 由于选择器失效，应该使用默认分支或保持原值
    return { 错误选择结果 };
  });
  
  // 汇总并输出测试报告
  console.log('\n========== 测试报告 ==========');
  console.log(`总测试数: ${测试报告.总测试数}`);
  console.log(`通过数: ${测试报告.通过数}`);
  console.log(`失败数: ${测试报告.失败数}`);
  
  if (测试报告.错误.length > 0) {
    console.log('\n测试错误:');
    测试报告.错误.forEach((错误, 索引) => {
      console.log(`${索引 + 1}. ${错误.测试名称}: ${错误.错误.message}`);
    });
  }
  
  console.log('\n========== 测试完成 ==========');
  
  return 测试报告;
}

// 运行测试
测试串链器分支功能();

// 导出测试函数
export { 测试串链器分支功能 };

