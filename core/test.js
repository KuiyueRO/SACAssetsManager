// 串链器测试用例.js
import { 创建串链器, 创建扩展定义 } from '../src/工具箱/forCore/串链器.js';

/**
 * 基础扩展测试
 */
const 测试基础扩展 = () => {
    // 创建串链器实例
    const 链 = 创建串链器();
    
    // 创建测试扩展
    const 测试扩展 = 创建扩展定义({
      ID: '测试扩展',
      版本: '1.0.0',
      描述: '用于测试的基础扩展',
      初始化: (扩展管理器, 定义接口, 全局态射表, 命名空间态射表, 配置) => {
        // 注册一个新的钩子点
        扩展管理器.注册钩子点('测试钩子', 数据 => 数据 * 2);
        
        // 定义扩展方法
        定义接口.态射('测试方法', 值 => 值 + 配置.增量);
        
        console.log('测试扩展已初始化');
      }
    });
    
    // 安装扩展
    链.扩展.安装(测试扩展, { 增量: 10 });
    
    // 测试扩展是否正确安装
    console.log('已安装扩展:', 链.扩展.列表());
    console.log('扩展信息:', 链.扩展.获取信息('测试扩展'));
    
    // 测试扩展方法
    const 结果 = 链(5).测试方法().值;
    console.log('测试方法结果:', 结果); // 应为 15
    
    // 测试扩展卸载
    链.扩展.卸载('测试扩展');
    console.log('卸载后扩展列表:', 链.扩展.列表());
    
    return 结果 === 15;
  };
  
  /**
   * 钩子点功能测试
   */
  const 测试钩子点功能 = () => {
    const 链 = 创建串链器();
    
    const 钩子测试扩展 = 创建扩展定义({
      ID: '钩子测试扩展',
      版本: '1.0.0',
      描述: '用于测试钩子点功能的扩展',
      初始化: (扩展管理器, 定义接口) => {
        // 修改前置处理钩子
        扩展管理器.修改钩子('前置处理', 原始值 => 原始值 * 2);
        
        // 修改后置处理钩子
        扩展管理器.修改钩子('后置处理', 结果 => 结果 + 5);
        
        // 增加一个自定义方法
        定义接口.态射('测试钩子', 值 => 值);
      }
    });
    
    链.扩展.安装(钩子测试扩展);
    
    // 测试钩子点是否生效
    const 结果 = 链(10).值; // 前置处理: 10*2=20, 后置处理: 20+5=25
    console.log('钩子处理结果:', 结果);
    
    return 结果 === 25;
  };
  
  /**
   * 扩展依赖关系测试
   */
  const 测试扩展依赖 = () => {
    const 链 = 创建串链器();
    
    // 创建基础扩展
    const 基础扩展 = 创建扩展定义({
      ID: '基础扩展',
      版本: '1.0.0',
      描述: '被依赖的基础扩展',
      初始化: (扩展管理器, 定义接口) => {
        定义接口.态射('基础方法', 值 => 值 * 2);
      }
    });
    
    // 创建依赖上述基础扩展的高级扩展
    const 高级扩展 = 创建扩展定义({
      ID: '高级扩展',
      版本: '1.0.0',
      描述: '依赖基础扩展的高级扩展',
      初始化: (扩展管理器, 定义接口) => {
        定义接口.态射('高级方法', 值 => 值 + 10);
      }
    });
    
    // 先安装基础扩展
    链.扩展.安装(基础扩展);
    
    // 再安装高级扩展，并指定依赖
    链.扩展.安装(高级扩展, { 依赖: '基础扩展' });
    
    // 测试依赖链是否正常工作
    const 结果 = 链(5).基础方法().高级方法().值;
    console.log('依赖链调用结果:', 结果); // 应为 (5*2)+10 = 20
    
    return 结果 === 20;
  };
  
  /**
   * 测试多个扩展协同工作
   */
  const 测试多扩展协同 = () => {
    const 链 = 创建串链器();
    
    // 数学扩展
    const 数学扩展 = 创建扩展定义({
      ID: '数学扩展',
      版本: '1.0.0',
      描述: '提供基础数学运算',
      初始化: (扩展管理器, 定义接口) => {
        定义接口.命名空间('数学')
          .加(值 => 值 + 10)
          .减(值 => 值 - 5)
          .乘(值 => 值 * 2)
          .退出命名空间();
      }
    });
    
    // 字符串扩展
    const 字符串扩展 = 创建扩展定义({
      ID: '字符串扩展',
      版本: '1.0.0',
      描述: '提供字符串操作',
      初始化: (扩展管理器, 定义接口) => {
        定义接口.命名空间('字符串')
          .前缀((值, 前缀) => 前缀 + 值)
          .后缀((值, 后缀) => 值 + 后缀)
          .退出命名空间();
      }
    });
    
    // 安装扩展
    链.扩展.安装(数学扩展);
    链.扩展.安装(字符串扩展);
    
    // 测试命名空间和多扩展协作
    const 数学结果 = 链(10).使用命名空间('数学').加().乘().减().值;
    console.log('数学扩展结果:', 数学结果); // 应为 ((10+10)*2)-5 = 35
    
    const 字符串结果 = 链('测试').使用命名空间('字符串').前缀('前缀-').后缀('-后缀').值;
    console.log('字符串扩展结果:', 字符串结果); // 应为 "前缀-测试-后缀"
    
    return 数学结果 === 35 && 字符串结果 === '前缀-测试-后缀';
  };
  
  /**
   * 测试自定义钩子扩展
   */
  const 测试自定义钩子扩展 = () => {
    const 链 = 创建串链器();
    
    // 创建一个全局可访问的调用历史数组
    const 全局调用历史 = [];
    
    // 日志钩子扩展
    const 日志扩展 = 创建扩展定义({
      ID: '日志扩展',
      版本: '1.0.0',
      描述: '提供方法调用日志记录',
      初始化: (扩展管理器, 定义接口) => {
        // 修改态射执行前钩子
        扩展管理器.修改钩子('态射执行前', (信息) => {
          if (信息 && typeof 信息 === 'object') {
            const { 态射名, 当前值 } = 信息;
            全局调用历史.push({ 态射: 态射名, 输入: 当前值, 时间: new Date() });
          }
          return 信息; // 原样返回信息对象
        });
        
        // 直接定义获取历史的方法，不使用钩子
        定义接口.态射('获取历史', () => 全局调用历史);
      }
    });
    
    链.扩展.安装(日志扩展);
    
    // 定义一些基础方法用于测试
    链.态射('加十', 值 => 值 + 10)
      .态射('乘二', 值 => 值 * 2);
    
    // 执行一系列操作
    链(5).加十().乘二().值;
    
    // 获取调用历史
    const 历史 = 链.获取历史().值;
    console.log('调用历史:', 历史);
    
    // 为了安全，先检查历史是否存在并且是一个数组
    if (Array.isArray(历史) && 历史.length >= 2) {
      return 历史[0].态射 === '加十' && 历史[1].态射 === '乘二';
    }
    
    // 如果使用钩子方式失败，直接使用全局调用历史
    console.log('使用全局调用历史:', 全局调用历史);
    return 全局调用历史.length === 2 && 
           全局调用历史[0].态射 === '加十' && 
           全局调用历史[1].态射 === '乘二';
  };
  
  // 运行所有测试
  const 运行所有测试 = () => {
    console.log('开始测试串链器扩展系统...');
    
    const 测试结果 = {
      '基础扩展测试': 测试基础扩展(),
      '钩子点功能测试': 测试钩子点功能(),
      '扩展依赖测试': 测试扩展依赖(),
      '多扩展协同测试': 测试多扩展协同(),
      '自定义钩子扩展测试': 测试自定义钩子扩展()
    };
    
    console.log('测试结果:', 测试结果);
    console.log('所有测试通过:', Object.values(测试结果).every(结果 => 结果));
  };
  
  运行所有测试();