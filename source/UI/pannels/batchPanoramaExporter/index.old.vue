<template>
  <div class="batch-exporter-container">
    <div class="panel-header">
      <h2>ÊâπÈáèÂÖ®ÊôØËßÜÈ¢ëÂØºÂá∫</h2>
      <div class="panel-actions">
        <button class="action-btn refresh-btn" @click="refreshFileList">
          <i class="icon">üîÑ</i>
          Âà∑Êñ∞
        </button>
      </div>
    </div>

    <div class="panel-body">
      <!-- Ê∫êÊñá‰ª∂ÈÄâÊã© -->
      <div class="section">
        <div class="section-header">
          <h3>Ê∫êÊñá‰ª∂</h3>
          <div class="header-actions">
            <button class="action-btn" @click="showFileSelector">
              <i class="icon">üìÇ</i>
              ÊµèËßàÊñá‰ª∂
            </button>
            <button class="action-btn" @click="clearSelectedFiles">
              <i class="icon">üóëÔ∏è</i>
              Ê∏ÖÁ©∫
            </button>
          </div>
        </div>
        
        <div class="file-list-container">
          <div v-if="selectedFiles.length === 0" class="empty-tip">
            Êú™ÈÄâÊã©Êñá‰ª∂ÔºåÁÇπÂáª"ÊµèËßàÊñá‰ª∂"Ê∑ªÂä†ÂÖ®ÊôØÂõæ
          </div>
          <div v-else class="file-list">
            <div v-for="(file, index) in selectedFiles" :key="index" class="file-item">
              <div class="file-preview">
                <img :src="file.thumbnail" alt="ÂÖ®ÊôØÂõæÈ¢ÑËßà" />
              </div>
              <div class="file-info">
                <div class="file-name">{{ file.name }}</div>
                <div class="file-path">{{ file.path }}</div>
              </div>
              <div class="file-actions">
                <button class="action-btn small" @click="removeFile(index)">
                  <i class="icon">‚ùå</i>
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- ÂØºÂá∫ËÆæÁΩÆ -->
      <div class="section">
        <div class="section-header">
          <h3>ÂØºÂá∫ËÆæÁΩÆ</h3>
          <div class="header-actions">
            <button class="action-btn" @click="addSettingProfile">
              <i class="icon">‚ûï</i>
              Ê∑ªÂä†ÈÖçÁΩÆ
            </button>
          </div>
        </div>
        
        <div class="settings-profiles-container">
          <div v-for="(profile, profileIndex) in settingProfiles" :key="profileIndex" class="setting-profile">
            <div class="profile-header">
              <h4>ÈÖçÁΩÆ #{{ profileIndex + 1 }}</h4>
              <div class="profile-actions">
                <button 
                  v-if="settingProfiles.length > 1" 
                  class="action-btn small" 
                  @click="removeSettingProfile(profileIndex)">
                  <i class="icon">‚ùå</i>
                </button>
              </div>
            </div>
            
            <div class="settings-grid">
              <div class="setting-group">
                <div class="setting-item">
                  <label>ËßÜÈ¢ëÂàÜËæ®Áéá</label>
                  <select v-model="profile.resolution">
                    <option value="1080p">1920√ó1080 (1080p)</option>
                    <option value="2k">2560√ó1440 (2K)</option>
                    <option value="4k">3840√ó2160 (4K)</option>
                  </select>
                </div>
                
                <div class="setting-item">
                  <label>ËßÜÈ¢ëÂ∏ßÁéá</label>
                  <select v-model="profile.fps">
                    <option :value="30">30 FPS</option>
                    <option :value="60">60 FPS</option>
                    <option :value="120">120 FPS</option>
                  </select>
                </div>
              </div>
              
              <div class="setting-group">
                <div class="setting-item">
                  <label>ËßÜÈ¢ëÊñπÂêë</label>
                  <select v-model="profile.isLandscape">
                    <option :value="true">Ê®™Â±è</option>
                    <option :value="false">Á´ñÂ±è</option>
                  </select>
                </div>
                
                <div class="setting-item">
                  <label>ËßÜÈ¢ëÊó∂Èïø</label>
                  <select v-model="profile.duration">
                    <option :value="12">12Áßí</option>
                    <option :value="24">24Áßí</option>
                    <option :value="30">30Áßí</option>
                    <option :value="40">40Áßí</option>
                  </select>
                </div>
              </div>
              
              <div class="setting-group">
                <div class="setting-item">
                  <label>ÊóãËΩ¨ÂúàÊï∞</label>
                  <select v-model="profile.rotations">
                    <option :value="1">1Âúà</option>
                    <option :value="2">2Âúà</option>
                    <option :value="3">3Âúà</option>
                  </select>
                </div>
                
                <div class="setting-item">
                  <label>Âπ≥ÊªëÂ∫¶</label>
                  <input type="range" v-model="profile.smoothness" min="0" max="1" step="0.1" />
                  <div class="range-value">{{ parseFloat(profile.smoothness).toFixed(1) }}</div>
                </div>
              </div>
            </div>
            
            <!-- Ê∑ªÂä†Ê∞¥Âç∞ËÆæÁΩÆ -->
            <div class="watermark-settings">
              <div class="watermark-header">
                <h4>Ê∞¥Âç∞ËÆæÁΩÆ</h4>
                <div class="expand-toggle" @click="toggleWatermarkExpand(profileIndex)">
                  {{ profile.watermarkExpanded ? 'Êî∂Ëµ∑' : 'Â±ïÂºÄ' }}
                </div>
              </div>
              
              <div class="watermark-content" v-if="profile.watermarkExpanded">
                <!-- Êîπ‰∏∫Â∑¶Âè≥ÂàÜÊ†èÂ∏ÉÂ±Ä -->
                <div class="watermark-layout">
                  <!-- Â∑¶‰æßÊ∞¥Âç∞ËÆæÁΩÆ -->
                  <div class="watermark-options-column">
                    <!-- ÊñáÂ≠óÊ∞¥Âç∞ËÆæÁΩÆ -->
                    <div class="watermark-section">
                      <div class="section-header">
                        <div class="section-title">ÊñáÂ≠óÊ∞¥Âç∞</div>
                        <div class="section-toggle">
                          <input 
                            type="checkbox" 
                            :id="`textWatermarkEnabled-${profileIndex}`" 
                            v-model="profile.watermark.text.enabled" 
                          />
                          <label :for="`textWatermarkEnabled-${profileIndex}`">ÂêØÁî®</label>
                        </div>
                      </div>
                      
                      <div class="watermark-options" v-if="profile.watermark.text.enabled">
                        <div class="setting-item">
                          <label>Ê∞¥Âç∞ÊñáÂ≠ó</label>
                          <input 
                            type="text" 
                            v-model="profile.watermark.text.text" 
                            placeholder="ËØ∑ËæìÂÖ•Ê∞¥Âç∞ÊñáÂ≠ó" 
                          />
                        </div>
                        
                        <!-- Êñ∞Â¢ûÂ≠ó‰ΩìÈÄâÊã©ÂäüËÉΩ -->
                        <div class="setting-item">
                          <label>Â≠ó‰Ωì</label>
                          <div class="font-selector">
                            <div class="font-selector-header" @click="toggleFontSelector(profileIndex)">
                              <span :style="{fontFamily: profile.watermark.text.fontFamily}">
                                {{ profile.watermark.text.fontFamily }}
                              </span>
                              <i class="icon">{{ fontSelectorOpen[profileIndex] ? 'üîº' : 'üîΩ' }}</i>
                            </div>
                            <div class="font-selector-dropdown" v-if="fontSelectorOpen[profileIndex]">
                              <div class="font-search">
                                <input 
                                  type="text" 
                                  v-model="fontSearchQuery[profileIndex]" 
                                  placeholder="ÊêúÁ¥¢Â≠ó‰Ωì..."
                                  @input="filterFonts(profileIndex)" 
                                />
                              </div>
                              <div class="font-list">
                                <div 
                                  v-for="font in filteredFonts[profileIndex]" 
                                  :key="font" 
                                  class="font-item"
                                  :class="{'selected': profile.watermark.text.fontFamily === font}"
                                  :style="{fontFamily: font}" 
                                  @click="selectFont(profileIndex, font)"
                                >
                                  {{ font }}
                                </div>
                              </div>
                            </div>
                          </div>
                        </div>
                        
                        <div class="setting-item">
                          <label>‰ΩçÁΩÆ</label>
                          <select v-model="profile.watermark.text.position">
                            <option value="topLeft">Â∑¶‰∏äËßí</option>
                            <option value="topRight">Âè≥‰∏äËßí</option>
                            <option value="bottomLeft">Â∑¶‰∏ãËßí</option>
                            <option value="bottomRight">Âè≥‰∏ãËßí</option>
                            <option value="center">Â±Ö‰∏≠</option>
                          </select>
                        </div>
                        
                        <div class="setting-item">
                          <label>Â≠ó‰ΩìÂ§ßÂ∞è</label>
                          <select v-model="profile.watermark.text.fontSize">
                            <option value="small">Â∞è</option>
                            <option value="medium">‰∏≠</option>
                            <option value="large">Â§ß</option>
                          </select>
                        </div>
                        
                        <div class="setting-item">
                          <label>ÊñáÂ≠óÈ¢úËâ≤</label>
                          <div class="color-picker">
                            <input type="color" v-model="profile.watermark.text.colorHex" @input="updateTextWatermarkColor(profileIndex)" />
                            <div class="transparency-slider">
                              <input 
                                type="range" 
                                v-model="profile.watermark.text.opacity" 
                                min="0" 
                                max="1" 
                                step="0.1" 
                                @input="updateTextWatermarkColor(profileIndex)" 
                              />
                              <div class="range-value">ÈÄèÊòéÂ∫¶: {{ parseFloat(profile.watermark.text.opacity).toFixed(1) }}</div>
                            </div>
                          </div>
                        </div>
                        
                        <!-- Â≠ó‰ΩìÈ¢ÑËßàÂå∫Âüü -->
                        <div class="font-preview-area">
                          <div class="preview-label">ÊñáÂ≠óÈ¢ÑËßà</div>
                          <div 
                            class="font-preview" 
                            :style="{
                              fontFamily: profile.watermark.text.fontFamily,
                              color: profile.watermark.text.color,
                              fontSize: getFontSizePreview(profile.watermark.text.fontSize)
                            }"
                          >
                            {{ profile.watermark.text.text || 'ÂÖ®ÊôØËßÜÈ¢ë' }}
                          </div>
                        </div>
                      </div>
                    </div>
                    
                    <!-- ÂõæÁâáÊ∞¥Âç∞ËÆæÁΩÆ -->
                    <div class="watermark-section">
                      <div class="section-header">
                        <div class="section-title">ÂõæÁâáÊ∞¥Âç∞</div>
                        <div class="section-toggle">
                          <input 
                            type="checkbox" 
                            :id="`imageWatermarkEnabled-${profileIndex}`" 
                            v-model="profile.watermark.image.enabled" 
                          />
                          <label :for="`imageWatermarkEnabled-${profileIndex}`">ÂêØÁî®</label>
                        </div>
                      </div>
                      
                      <div class="watermark-options" v-if="profile.watermark.image.enabled">
                        <div class="setting-item">
                          <label>Ê∞¥Âç∞ÂõæÁâá</label>
                          <div class="image-selector">
                            <button class="action-btn" @click="selectWatermarkImage(profileIndex)">
                              <i class="icon">üì∑</i>
                              ÈÄâÊã©ÂõæÁâá
                            </button>
                            <div v-if="profile.watermark.image.preview" class="image-preview">
                              <img :src="profile.watermark.image.preview" alt="Ê∞¥Âç∞È¢ÑËßà" />
                            </div>
                          </div>
                        </div>
                        
                        <div class="setting-item">
                          <label>‰ΩçÁΩÆ</label>
                          <select v-model="profile.watermark.image.position">
                            <option value="topLeft">Â∑¶‰∏äËßí</option>
                            <option value="topRight">Âè≥‰∏äËßí</option>
                            <option value="bottomLeft">Â∑¶‰∏ãËßí</option>
                            <option value="bottomRight">Âè≥‰∏ãËßí</option>
                            <option value="center">Â±Ö‰∏≠</option>
                          </select>
                        </div>
                        
                        <div class="setting-item">
                          <label>Â§ßÂ∞è (Âç†ËßÜÈ¢ëÂÆΩÂ∫¶ÁöÑÁôæÂàÜÊØî)</label>
                          <div class="range-with-value">
                            <input 
                              type="range" 
                              v-model="profile.watermark.image.size" 
                              min="0.05" 
                              max="0.3" 
                              step="0.01" 
                            />
                            <div class="range-value">{{ Math.round(profile.watermark.image.size * 100) }}%</div>
                          </div>
                        </div>
                        
                        <div class="setting-item">
                          <label>ÈÄèÊòéÂ∫¶</label>
                          <div class="range-with-value">
                            <input 
                              type="range" 
                              v-model="profile.watermark.image.opacity" 
                              min="0" 
                              max="1" 
                              step="0.1" 
                            />
                            <div class="range-value">{{ parseFloat(profile.watermark.image.opacity).toFixed(1) }}</div>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                  
                  <!-- Âè≥‰æßÊ∞¥Âç∞È¢ÑËßà -->
                  <div class="watermark-preview-column" v-if="hasWatermarkEnabled(profile)">
                    <div class="watermark-preview-section">
                      <div class="section-header">
                        <div class="section-title">Ê∞¥Âç∞ÊïàÊûúÈ¢ÑËßà</div>
                        <div class="section-toggle">
                          <button class="action-btn small" @click="generateWatermarkPreview(profileIndex)" :disabled="!canGeneratePreview">
                            <i class="icon">üîÑ</i>
                            Êõ¥Êñ∞È¢ÑËßà
                          </button>
                        </div>
                      </div>
                      
                      <div class="preview-container">
                        <div v-if="!profile.previewImage" class="empty-preview" :style="getPreviewContainerStyle(profile)">
                          <div v-if="canGeneratePreview">ÁÇπÂáª"Êõ¥Êñ∞È¢ÑËßà"ÊåâÈíÆÊü•ÁúãÊ∞¥Âç∞ÊïàÊûú</div>
                          <div v-else>ËØ∑ÂÖàÈÄâÊã©ÂÖ®ÊôØÂõæ‰ª•ÁîüÊàêÈ¢ÑËßà</div>
                        </div>
                        <div v-else-if="profile.previewError" class="preview-error">
                          <div class="error-icon">‚ö†Ô∏è</div>
                          <div class="error-message">Ê∏≤ÊüìÂ§±Ë¥•: {{ profile.previewError }}</div>
                        </div>
                        <div v-else class="frame-preview">
                          <img :src="profile.previewImage" alt="Ê∞¥Âç∞È¢ÑËßà" />
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="setting-item">
          <label>ËæìÂá∫ÁõÆÂΩï</label>
          <div class="output-path-selector">
            <input type="text" v-model="outputDir" readonly placeholder="ÁÇπÂáªÈÄâÊã©ËæìÂá∫ÁõÆÂΩï" />
            <button class="action-btn" @click="selectOutputDir">
              <i class="icon">üìÅ</i>
              ÈÄâÊã©
            </button>
          </div>
        </div>

        <div class="setting-item">
          <div class="checkbox-wrapper">
            <input type="checkbox" id="createSubDirs" v-model="createSubDirs">
            <label for="createSubDirs">‰∏∫ÊØè‰∏™Êñá‰ª∂ÂàõÂª∫Â≠êÁõÆÂΩï</label>
          </div>
        </div>
      </div>

      <!-- ÊâπÂ§ÑÁêÜ‰ªªÂä° -->
      <div class="section">
        <div class="section-header">
          <h3>ÊâπÂ§ÑÁêÜ‰ªªÂä°</h3>
          <div class="header-actions">
            <button class="action-btn primary" 
                    @click="startBatchExport" 
                    :disabled="!canStartExport || isExporting">
              <i class="icon">üöÄ</i>
              {{ isExporting ? 'ÂØºÂá∫‰∏≠...' : 'ÂºÄÂßãÊâπÈáèÂØºÂá∫' }}
            </button>
          </div>
        </div>
        
        <div class="tasks-container">
          <div v-if="tasks.length === 0" class="empty-tip">
            ‰ªªÂä°ÂàóË°®‰∏∫Á©∫„ÄÇËÆæÁΩÆÂØºÂá∫ÈÄâÈ°πÂêéÁÇπÂáª"ÂºÄÂßãÊâπÈáèÂØºÂá∫"
          </div>
          <div v-else class="task-list">
            <div v-for="(task, index) in tasks" :key="index" class="task-item" :class="{'task-completed': task.status === 'completed', 'task-error': task.status === 'error'}">
              <div class="task-info">
                <div class="task-name">
                  <span class="file-name">{{ task.fileName }}</span>
                  <span v-if="task.profileIndex !== undefined" class="profile-badge">ÈÖçÁΩÆ #{{ task.profileIndex + 1 }}</span>
                </div>
                <div class="task-status">{{ getTaskStatusText(task) }}</div>
              </div>
              <div class="task-progress">
                <div class="progress-bar">
                  <div class="progress-fill" :style="{width: `${task.progress * 100}%`}"></div>
                </div>
                <div class="progress-details">
                  <div class="progress-value">{{ Math.round(task.progress * 100) }}%</div>
                  <div v-if="task.stage" class="stage-info">
                    {{ task.stage }} 
                    <span v-if="task.currentFrame && task.totalFrames">
                      ({{ task.currentFrame }}/{{ task.totalFrames }} Â∏ß)
                    </span>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
        
        <div v-if="isExporting" class="overall-progress">
          <div class="progress-info">
            <div>ÊÄª‰ΩìËøõÂ∫¶Ôºö{{ Math.round(overallProgress * 100) }}%</div>
            <div>Â∑≤ÂÆåÊàêÔºö{{ completedCount }}/{{ totalCount }}</div>
          </div>
          <div class="progress-bar">
            <div class="progress-fill" :style="{width: `${overallProgress * 100}%`}"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted, defineProps, reactive, watch } from 'vue';
import { PanoramaVideoGenerator, saveVideoBlob, captureFrame } from '../pannoViewer/panoramaToVideo.js';
import * as THREE from '../../../../static/three/three.mjs';
import { clientApi, plugin, kernelApi } from '../../../asyncModules.js'
import { addTextWatermark, addImageWatermark } from '../pannoViewer/watermarkUtils.js';

// ÂÆö‰πâpropsÔºåÊé•Êî∂ÂØπËØùÊ°Ü‰º†ÈÄíÁöÑÊï∞ÊçÆ
const props = defineProps({
  sourceType: String,
  currentImage: Object,
  settings: Object
});

// ‰∫ã‰ª∂ÊÄªÁ∫øÂºïÁî®
let eventBus;

// Áä∂ÊÄÅÁÆ°ÁêÜ
const selectedFiles = ref([]);
const settingProfiles = ref([
  {
    resolution: '1080p',
    fps: 30,
    duration: 24,
    isLandscape: true,
    rotations: 1,
    smoothness: 0.8,
    // Ê∑ªÂä†Ê∞¥Âç∞ËÆæÁΩÆ
    watermarkExpanded: false,
    watermark: {
      text: {
        enabled: false,
        text: 'ÂÖ®ÊôØËßÜÈ¢ë',
        position: 'bottomRight',
        fontSize: 'medium', // small, medium, large
        colorHex: '#ffffff',
        opacity: 0.8,
        color: 'rgba(255, 255, 255, 0.8)',
        fontFamily: 'Arial' // ÈªòËÆ§Â≠ó‰Ωì
      },
      image: {
        enabled: false,
        file: null,
        preview: null,
        position: 'bottomLeft',
        size: 0.15, // Âç†ËßÜÈ¢ëÂÆΩÂ∫¶ÁôæÂàÜÊØî
        opacity: 0.8
      }
    },
    previewImage: null, // Â≠òÂÇ®È¢ÑËßàÂõæURL
    previewError: null  // Â≠òÂÇ®È¢ÑËßàÈîôËØØ‰ø°ÊÅØ
  }
]);
const outputDir = ref('');
const createSubDirs = ref(true);

const tasks = ref([]);
const isExporting = ref(false);
const currentTaskIndex = ref(-1);

// Ê∑ªÂä†Â≠ó‰ΩìÁõ∏ÂÖ≥ÁöÑÁä∂ÊÄÅ
const availableFonts = ref([]);
const fontSelectorOpen = reactive({});
const fontSearchQuery = reactive({});
const filteredFonts = reactive({});

// Ê∑ªÂä†‰∏Ä‰∏™ÁºìÂ≠òÂØπË±°Áî®‰∫éÂ≠òÂÇ®È¢ÑËßàÂô®ÂÆû‰æãÂíåÁ∫πÁêÜ
const previewerCache = ref({});

// Ëé∑ÂèñÁ≥ªÁªüÂ≠ó‰Ωì
const loadSystemFonts = async () => {
  try {
    const fonts = await kernelApi.getSysFonts();
    availableFonts.value = Array.isArray(fonts) ? fonts : [];
    console.log('Âä†ËΩΩ‰∫ÜÁ≥ªÁªüÂ≠ó‰Ωì:', availableFonts.value.length);
    
    // ÂàùÂßãÂåñÊØè‰∏™ÈÖçÁΩÆÊñá‰ª∂ÁöÑËøáÊª§Â≠ó‰Ωì
    settingProfiles.value.forEach((_, index) => {
      filteredFonts[index] = [...availableFonts.value];
      fontSearchQuery[index] = '';
      fontSelectorOpen[index] = false;
    });
  } catch (error) {
    console.error('Ëé∑ÂèñÁ≥ªÁªüÂ≠ó‰ΩìÂ§±Ë¥•:', error);
    // ËÆæÁΩÆÈªòËÆ§Â≠ó‰ΩìÂàóË°®
    availableFonts.value = ['Arial', 'Verdana', 'Helvetica', 'Times New Roman', 'Courier New', 'Georgia', 'Palatino', 'Garamond', 'Bookman', 'Tahoma', 'Trebuchet MS'];
    
    // ÂàùÂßãÂåñÊØè‰∏™ÈÖçÁΩÆÊñá‰ª∂ÁöÑËøáÊª§Â≠ó‰Ωì
    settingProfiles.value.forEach((_, index) => {
      filteredFonts[index] = [...availableFonts.value];
      fontSearchQuery[index] = '';
      fontSelectorOpen[index] = false;
    });
  }
};

// ÂàáÊç¢Â≠ó‰ΩìÈÄâÊã©Âô®
const toggleFontSelector = (profileIndex) => {
  fontSelectorOpen[profileIndex] = !fontSelectorOpen[profileIndex];
  
  // ÁÇπÂáªÂ§ñÈÉ®ÂÖ≥Èó≠ÈÄâÊã©Âô®
  if (fontSelectorOpen[profileIndex]) {
    setTimeout(() => {
      const clickListener = (e) => {
        const selector = document.querySelector(`.setting-profile:nth-child(${profileIndex + 1}) .font-selector`);
        if (selector && !selector.contains(e.target)) {
          fontSelectorOpen[profileIndex] = false;
          document.removeEventListener('click', clickListener);
        }
      };
      document.addEventListener('click', clickListener);
    }, 0);
  }
};

// Ê†πÊçÆÊêúÁ¥¢ËØçËøáÊª§Â≠ó‰Ωì
const filterFonts = (profileIndex) => {
  const query = fontSearchQuery[profileIndex].toLowerCase();
  if (!query) {
    filteredFonts[profileIndex] = [...availableFonts.value];
  } else {
    filteredFonts[profileIndex] = availableFonts.value.filter(
      font => font.toLowerCase().includes(query)
    );
  }
};

// ÈÄâÊã©Â≠ó‰Ωì
const selectFont = (profileIndex, font) => {
  settingProfiles.value[profileIndex].watermark.text.fontFamily = font;
  fontSelectorOpen[profileIndex] = false;
};

// Ëé∑ÂèñÈ¢ÑËßàÁî®ÁöÑÂ≠ó‰ΩìÂ§ßÂ∞è
const getFontSizePreview = (size) => {
  switch (size) {
    case 'small': return '14px';
    case 'large': return '24px';
    case 'medium':
    default: return '18px';
  }
};

// ËÆ°ÁÆóÂ±ûÊÄß
const canStartExport = computed(() => {
  return selectedFiles.value.length > 0 && 
         outputDir.value && 
         !isExporting.value;
});

const overallProgress = computed(() => {
  if (tasks.value.length === 0) return 0;
  
  const totalProgress = tasks.value.reduce((sum, task) => sum + task.progress, 0);
  return totalProgress / tasks.value.length;
});

const completedCount = computed(() => {
  return tasks.value.filter(task => task.status === 'completed').length;
});

const totalCount = computed(() => {
  return tasks.value.length;
});

// Âà§Êñ≠ÊòØÂê¶ÂèØ‰ª•ÁîüÊàêÈ¢ÑËßà
const canGeneratePreview = computed(() => {
  return selectedFiles.value.length > 0;
});

// Âà§Êñ≠ÊòØÂê¶ÊúâÊ∞¥Âç∞ÂêØÁî®
const hasWatermarkEnabled = (profile) => {
  return profile.watermark.text.enabled || profile.watermark.image.enabled;
};

// Ëé∑ÂèñÈ¢ÑËßàÂÆπÂô®Ê†∑ÂºèÔºåÁ°Æ‰øùÂÆΩÈ´òÊØîÊ≠£Á°Æ
const getPreviewContainerStyle = (profile) => {
  if (profile.isLandscape) {
    // Ê®™Â±è 16:9
    return { 
      width: '100%',
      paddingBottom: '56.25%', // 9/16 = 0.5625 = 56.25%
      position: 'relative',
      height: '0'
    };
  } else {
    // Á´ñÂ±è 9:16
    return {
      width: '56.25%', // Áõ∏ÂØπ‰∫éÁà∂ÂÆπÂô®ÁöÑÂÆΩÂ∫¶
      paddingBottom: '100%', // È´òÂ∫¶ÊòØÂÆΩÂ∫¶ÁöÑ16/9ÂÄç
      position: 'relative',
      height: '0',
      margin: '0 auto'
    };
  }
};

// ‰øÆÊîπÁîüÊàêÊ∞¥Âç∞È¢ÑËßàÁöÑÊñπÊ≥ïÔºåÁ°Æ‰øùÊ∞¥Âç∞Â∞∫ÂØ∏ÊØî‰æã‰∏éÂØºÂá∫Êó∂Áõ∏Âêå
const generateWatermarkPreview = async (profileIndex) => {
  if (!canGeneratePreview.value) return;
  
  const profile = settingProfiles.value[profileIndex];
  const selectedFile = selectedFiles.value[0]; // ‰ΩøÁî®Á¨¨‰∏Ä‰∏™Êñá‰ª∂‰Ωú‰∏∫È¢ÑËßà
  
  try {
    // ÈáçÁΩÆÈ¢ÑËßàÈîôËØØ‰ø°ÊÅØ
    profile.previewError = null;
    
    // Âä†ËΩΩÂõæÂÉè
    const texture = await loadImageTexture(selectedFile);
    if (!texture) {
      showWarningMessage('Êó†Ê≥ïÂä†ËΩΩÂõæÂÉèËøõË°åÈ¢ÑËßà');
      return;
    }
    
    // Ê†πÊçÆÊñπÂêëË∞ÉÊï¥È¢ÑËßàÂ∞∫ÂØ∏Ôºå‰øùÊåÅÊ≠£Á°ÆÁöÑÂÆΩÈ´òÊØî
    let previewWidth, previewHeight;
    
    if (profile.isLandscape) {
      // Ê®™Â±èÊ®°Âºè 16:9
      previewWidth = 640;
      previewHeight = 360; // 16:9 ÊØî‰æã
    } else {
      // Á´ñÂ±èÊ®°Âºè 9:16
      previewWidth = 360;
      previewHeight = 640; // 9:16 ÊØî‰æã
    }
    
    // ËÆ°ÁÆóÈ¢ÑËßà‰∏éÂÆûÈôÖÂØºÂá∫ÁöÑÁº©ÊîæÊØî‰æã
    // Ëé∑ÂèñÂÆûÈôÖÂØºÂá∫ÂàÜËæ®ÁéáÂÆΩÂ∫¶
    let exportWidth;
    switch(profile.resolution) {
      case '4k':
        exportWidth = profile.isLandscape ? 3840 : 2160;
        break;
      case '2k':
        exportWidth = profile.isLandscape ? 2560 : 1440;
        break;
      default: // 1080p
        exportWidth = profile.isLandscape ? 1920 : 1080;
    }
    
    // ËÆ°ÁÆóÁº©ÊîæÊØî‰æã (È¢ÑËßàÂÆΩÂ∫¶/ÂØºÂá∫ÂÆΩÂ∫¶)
    const scaleRatio = previewWidth / exportWidth;
    
    // ÂàõÂª∫‰∏Ä‰∏™‰∏¥Êó∂ÁöÑCanvasÂÖÉÁ¥†Áî®‰∫éÊ∏≤Êüì
    const canvas = document.createElement('canvas');
    canvas.width = previewWidth;
    canvas.height = previewHeight;
    const ctx = canvas.getContext('2d');
    
    // ÂàõÂª∫‰∏Ä‰∏™‰∏¥Êó∂ÁöÑÊ∏≤ÊüìÂÆπÂô®
    const container = document.createElement('div');
    container.style.position = 'absolute';
    container.style.left = '-9999px';
    container.style.top = '-9999px';
    document.body.appendChild(container);
    
    // ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑPanoramaVideoGeneratorÂÆû‰æã
    const generator = new PanoramaVideoGenerator(previewWidth, previewHeight);
    
    // ‰ΩøÁî®try-finallyÁ°Æ‰øùËµÑÊ∫êÊ∏ÖÁêÜ
    try {
      // ËÆæÁΩÆÂú∫ÊôØ
      await generator.setupScene(texture);
      
      // È¢ÑÂ§ÑÁêÜÊ∞¥Âç∞ÈÄâÈ°π - Á°Æ‰øù‰∏éÂØºÂá∫Êó∂ÁöÑÊ∞¥Âç∞ÊØî‰æã‰∏ÄËá¥
      if (profile.watermark.text.enabled) {
        // ËÆ°ÁÆó‰∏éÂØºÂá∫Áõ∏ÂêåÊØî‰æãÁöÑÂ≠ó‰ΩìÂ§ßÂ∞è
        let fontSize;
        switch (profile.watermark.text.fontSize) {
          case 'small':
            fontSize = Math.max(16 * scaleRatio, exportWidth / 60 * scaleRatio);
            break;
          case 'large':
            fontSize = Math.max(32 * scaleRatio, exportWidth / 30 * scaleRatio);
            break;
          case 'medium':
          default:
            fontSize = Math.max(24 * scaleRatio, exportWidth / 45 * scaleRatio);
        }
        
        // ËÆæÁΩÆÊñáÂ≠óÊ∞¥Âç∞
        generator.setTextWatermark({
          enabled: true,
          text: profile.watermark.text.text || 'ÂÖ®ÊôØËßÜÈ¢ë',
          position: profile.watermark.text.position,
          font: `${Math.round(fontSize)}px ${profile.watermark.text.fontFamily}`,
          color: profile.watermark.text.color
        });
        
        console.log('È¢ÑËßàÊñáÂ≠óÊ∞¥Âç∞Â§ßÂ∞è:', Math.round(fontSize), 'pxÔºàÊåâÂÆûÈôÖÂØºÂá∫', Math.round(fontSize/scaleRatio), 'pxÊØî‰æãÁº©ÊîæÔºâ');
      }
      
      // Â§ÑÁêÜÂõæÁâáÊ∞¥Âç∞ - Â∫îÁî®Áõ∏ÂêåÁöÑÁº©ÊîæÊØî‰æã
      if (profile.watermark.image.enabled && profile.watermark.image.preview) {
        await generator.setImageWatermark({
          imageUrl: profile.watermark.image.preview,
          position: profile.watermark.image.position,
          width: profile.watermark.image.size, // Ê∞¥Âç∞ÂÆΩÂ∫¶‰ΩøÁî®ÁôæÂàÜÊØîË°®Á§∫Ôºå‰∏çÈúÄË¶ÅÁº©Êîæ
          opacity: profile.watermark.image.opacity
        });
      }
      
      // Ê∏≤Êüì‰∏ÄÂ∏ß
      // ÂàõÂª∫Ê∏≤ÊüìÂô®Âπ∂Ê∑ªÂä†Âà∞DOM
      generator.renderer.domElement.style.width = `${previewWidth}px`;
      generator.renderer.domElement.style.height = `${previewHeight}px`;
      container.appendChild(generator.renderer.domElement);
      
      // ËÆæÁΩÆÁõ∏Êú∫‰ΩçÁΩÆ
      generator.camera.position.set(0, 0, 0);
      generator.camera.rotation.set(0, 0, 0);
      generator.camera.rotateY(THREE.MathUtils.degToRad(0)); // ÂàùÂßãÁªèÂ∫¶
      generator.camera.rotateX(THREE.MathUtils.degToRad(0)); // ÂàùÂßãÁ∫¨Â∫¶
      
      // Â∞ùËØï‰ΩøÁî®captureFrameÊ∏≤Êüì
      try {
        const frameData = await captureFrame(
          generator.renderer,
          generator.scene,
          generator.camera,
          previewWidth, 
          previewHeight,
          true,
          {
            text: generator.watermarkOptions.text,
            image: generator.watermarkOptions.image
          }
        );
        
        // Â§çÂà∂Ê∏≤ÊüìÁªìÊûúÂà∞Êàë‰ª¨ÁöÑCanvas
        if (frameData && frameData.imageData) {
          ctx.drawImage(frameData.imageData, 0, 0);
        } else {
          // Â¶ÇÊûúcaptureFrame‰∏çÂèØÁî®ÔºåÁõ¥Êé•‰ªérendererËé∑ÂèñÂõæÂÉè
          generator.renderer.render(generator.scene, generator.camera);
          ctx.drawImage(generator.renderer.domElement, 0, 0);
          
          // ÊâãÂä®Ê∑ªÂä†Ê∞¥Âç∞
          if (profile.watermark.text.enabled) {
            addWatermarkToCanvas(canvas, profile, exportWidth, scaleRatio);
          }
        }
      } catch (error) {
        console.error('ÊçïËé∑Â∏ßÂ§±Ë¥•Ôºå‰ΩøÁî®Â§áÁî®ÊñπÊ≥ï:', error);
        
        // Â§áÁî®ÊñπÊ≥ïÔºöÁõ¥Êé•Ê∏≤ÊüìÂú∫ÊôØ
        generator.renderer.render(generator.scene, generator.camera);
        ctx.drawImage(generator.renderer.domElement, 0, 0);
        
        // ÊâãÂä®Ê∑ªÂä†Ê∞¥Âç∞
        if (profile.watermark.text.enabled) {
          addWatermarkToCanvas(canvas, profile, exportWidth, scaleRatio);
        }
      }
      
      // Â∞ÜCanvasËΩ¨Êç¢‰∏∫Êï∞ÊçÆURL
      const dataUrl = canvas.toDataURL('image/jpeg', 0.95);
      profile.previewImage = dataUrl;
    } catch (error) {
      console.error('Ê∏≤ÊüìÈ¢ÑËßàÂ§±Ë¥•:', error);
      profile.previewError = error.message;
      showWarningMessage(`ÁîüÊàêÈ¢ÑËßàÂ§±Ë¥•: ${error.message}`);
    } finally {
      // Ê∏ÖÁêÜËµÑÊ∫ê
      try {
        if (generator.renderer) {
          if (generator.renderer.domElement && generator.renderer.domElement.parentNode) {
            generator.renderer.domElement.parentNode.removeChild(generator.renderer.domElement);
          }
          generator.renderer.dispose();
        }
        if (container && container.parentNode) {
          container.parentNode.removeChild(container);
        }
      } catch (cleanupError) {
        console.warn('Ê∏ÖÁêÜÈ¢ÑËßàËµÑÊ∫êÊó∂Âá∫Èîô:', cleanupError);
      }
    }
  } catch (error) {
    console.error('ÁîüÊàêÈ¢ÑËßàÊÄª‰ΩìÂ§±Ë¥•:', error);
    profile.previewError = error.message;
    showWarningMessage(`ÁîüÊàêÈ¢ÑËßàÂ§±Ë¥•: ${error.message}`);
  }
};

// ‰øÆÊîπÊâãÂä®Ê∑ªÂä†Ê∞¥Âç∞ÁöÑÊñπÊ≥ïÔºåÂ∫îÁî®Ê≠£Á°ÆÁöÑÁº©ÊîæÊØî‰æã
const addWatermarkToCanvas = (canvas, profile, exportWidth, scaleRatio) => {
  const ctx = canvas.getContext('2d');
  if (!ctx) return;
  
  const { text, position, fontFamily, fontSize, color } = profile.watermark.text;
  
  // ËÆ°ÁÆó‰∏éÂØºÂá∫Êó∂Áõ∏ÂêåÊØî‰æãÁöÑÂ≠ó‰ΩìÂ§ßÂ∞è
  let fontSizePixels;
  switch (fontSize) {
    case 'small':
      fontSizePixels = Math.max(16 * scaleRatio, exportWidth / 60 * scaleRatio);
      break;
    case 'large':
      fontSizePixels = Math.max(32 * scaleRatio, exportWidth / 30 * scaleRatio);
      break;
    case 'medium':
    default:
      fontSizePixels = Math.max(24 * scaleRatio, exportWidth / 45 * scaleRatio);
  }
  
  // ËÆæÁΩÆÊ†∑Âºè
  ctx.font = `${Math.round(fontSizePixels)}px ${fontFamily}`;
  ctx.fillStyle = color;
  ctx.textBaseline = 'middle';
  
  // ÊµãÈáèÊñáÊú¨Â∞∫ÂØ∏
  const metrics = ctx.measureText(text || 'ÂÖ®ÊôØËßÜÈ¢ë');
  const textWidth = metrics.width;
  const textHeight = fontSizePixels;
  
  // ËÆ°ÁÆóÂÜÖËæπË∑ù - ‰πüÂ∫îÁî®Áõ∏ÂêåÁöÑÁº©ÊîæÊØî‰æã
  const padding = Math.max(10 * scaleRatio, exportWidth / 100 * scaleRatio);
  
  // Ê†πÊçÆ‰ΩçÁΩÆËÆ°ÁÆóÂùêÊ†á
  let x, y;
  switch(position) {
    case 'topLeft':
      x = padding;
      y = padding + textHeight / 2;
      break;
    case 'topRight':
      x = canvas.width - textWidth - padding;
      y = padding + textHeight / 2;
      break;
    case 'bottomLeft':
      x = padding;
      y = canvas.height - padding - textHeight / 2;
      break;
    case 'bottomRight':
      x = canvas.width - textWidth - padding;
      y = canvas.height - padding - textHeight / 2;
      break;
    case 'center':
      x = (canvas.width - textWidth) / 2;
      y = canvas.height / 2;
      break;
    default:
      x = padding;
      y = canvas.height - padding - textHeight / 2;
  }
  
  // ÁªòÂà∂ÊñáÂ≠ó
  ctx.fillText(text || 'ÂÖ®ÊôØËßÜÈ¢ë', x, y);
};

// ÁõëÂê¨Ê∞¥Âç∞ËÆæÁΩÆÂèòÂåñÔºåËá™Âä®Êõ¥Êñ∞È¢ÑËßà - ‰ºòÂåñÈò≤Êäñ
const updatePreviewDebounced = debounce((profileIndex) => {
  if (canGeneratePreview.value) {
    console.log('Ê∞¥Âç∞ËÆæÁΩÆÂ∑≤Êõ¥ÊîπÔºåÊõ¥Êñ∞È¢ÑËßà');
    generateWatermarkPreview(profileIndex);
  }
}, 300); // 300msÈò≤ÊäñÂª∂Ëøü

// Ê∑ªÂä†Èò≤ÊäñÂáΩÊï∞
function debounce(func, wait) {
  let timeout;
  return function executedFunction(...args) {
    const later = () => {
      clearTimeout(timeout);
      func(...args);
    };
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
  };
}

watch(
  () => settingProfiles.value.map(profile => ({
    textEnabled: profile.watermark.text.enabled,
    text: profile.watermark.text.text,
    textPosition: profile.watermark.text.position,
    fontSize: profile.watermark.text.fontSize,
    fontFamily: profile.watermark.text.fontFamily,
    color: profile.watermark.text.color,
    imageEnabled: profile.watermark.image.enabled,
    imagePosition: profile.watermark.image.position,
    imageSize: profile.watermark.image.size,
    imageOpacity: profile.watermark.image.opacity,
    isLandscape: profile.isLandscape
  })),
  (newVal, oldVal) => {
    // ÊâæÂá∫Âì™‰∏™ÈÖçÁΩÆÂèëÁîü‰∫ÜÂèòÂåñ
    for (let i = 0; i < newVal.length; i++) {
      if (oldVal && oldVal[i] && JSON.stringify(newVal[i]) !== JSON.stringify(oldVal[i])) {
        // ‰ΩøÁî®Èò≤ÊäñÂáΩÊï∞Êõ¥Êñ∞È¢ÑËßà
        updatePreviewDebounced(i);
        break;
      }
    }
  },
  { deep: true }
);

// ‰ªéÊñá‰ª∂Âä†ËΩΩÁ∫πÁêÜ
const loadImageTexture = async (fileInfo) => {
  return new Promise((resolve, reject) => {
    try {
      const img = new Image();
      
      img.onload = () => {
        const texture = new THREE.Texture(img);
        texture.needsUpdate = true;
        resolve(texture);
      };
      
      img.onerror = () => {
        reject(new Error('Êó†Ê≥ïÂä†ËΩΩÂõæÂÉè'));
      };
      
      // Ê†πÊçÆÊñá‰ª∂‰ø°ÊÅØËÆæÁΩÆÂõæÂÉèÊ∫ê
      if (fileInfo.file) {
        const objectUrl = URL.createObjectURL(fileInfo.file);
        img.src = objectUrl;
      } else if (fileInfo.path) {
        img.src = fileInfo.path;
      } else {
        reject(new Error('Êó†ÊïàÁöÑÊñá‰ª∂‰ø°ÊÅØ'));
      }
    } catch (error) {
      reject(error);
    }
  });
};

// Êñá‰ª∂ÂàóË°®ÂèòÂåñÊó∂ÊâßË°åÈÉ®ÂàÜÊ∏ÖÁêÜ
watch(selectedFiles, () => {
  // ÂΩìÊñá‰ª∂ÂàóË°®ÂèòÂåñÊó∂ÔºåÊ∏ÖÁêÜÈ¢ÑËßàÁºìÂ≠ò
  Object.values(previewerCache.value).forEach(item => {
    if (item.previewer && item.previewer.dispose) {
      item.previewer.dispose();
    }
  });
  previewerCache.value = {};
  
  // Ê∏ÖÈô§ÊâÄÊúâÈ¢ÑËßàÂõæ
  settingProfiles.value.forEach(profile => {
    profile.previewImage = null;
  });
}, { deep: true });

// Ê≥®ÂÜå‰∫ã‰ª∂ÁõëÂê¨Âô®ÂíåÊï∞ÊçÆÊé•Êî∂
const setupEventListeners = () => {
  // ÂØπËØùÊ°ÜÊ®°ÂºèÔºöÊ£ÄÊü•ÁªÑ‰ª∂ÁöÑdataÂ±ûÊÄß
  if (props && props.sourceType) {
    console.log('ÂØπËØùÊ°ÜÊ®°ÂºèÔºö‰ªépropsËé∑ÂèñÊï∞ÊçÆ');
    handleReceivedData(props);
    return;
  }
  
  // TabÊ®°ÂºèÔºö‰ªéTabÂ±ûÊÄßËé∑ÂèñÊï∞ÊçÆ
  if (window.siyuan && window.siyuan.menus) {
    // Ëé∑ÂèñÂΩìÂâçTab ID
    const tabID = plugin.name + 'batchPanoramaExporterTab';
    
    // ‰ªéÂΩìÂâçTabÊï∞ÊçÆ‰∏≠Ëé∑Âèñ‰º†ÂÖ•ÁöÑÊï∞ÊçÆ
    const tab = document.querySelector(`[data-id="${tabID}"]`);
    if (tab) {
      const tabModel = tab.getAttribute('data-model');
      if (tabModel) {
        try {
          // Â∞ùËØïËß£ÊûêÊï∞ÊçÆ
          const tabData = JSON.parse(tabModel);
          if (tabData && tabData.data) {
            handleReceivedData(tabData.data);
          }
        } catch (error) {
          console.error('Ëß£ÊûêTabÊï∞ÊçÆÂ§±Ë¥•:', error);
        }
      }
    }
  }
};

// Â§ÑÁêÜÊé•Êî∂Âà∞ÁöÑÊï∞ÊçÆ
const handleReceivedData = async (data) => {
  if (!data) return;
  
  console.log('ÊâπÈáèÂØºÂá∫Âô®Êî∂Âà∞Êï∞ÊçÆ:', data);
  
  // Â¶ÇÊûú‰ªéÂÖ®ÊôØÈ¢ÑËßàÂô®‰º†Êù•‰∫ÜÂΩìÂâçÂõæÂÉèÔºåÊ∑ªÂä†Âà∞Êñá‰ª∂ÂàóË°®
  if (data.sourceType === 'panorama' && data.currentImage?.path) {
    try {
      // Âä†ËΩΩÂõæÂÉèÂπ∂ÁîüÊàêÁº©Áï•Âõæ
      const thumbnail = await generateThumbnailFromPath(data.currentImage.path);
      
      // Ê£ÄÊü•ÂΩìÂâçÊñá‰ª∂ÂàóË°®‰∏≠ÊòØÂê¶Â∑≤ÊúâÊ≠§Êñá‰ª∂
      const exists = selectedFiles.value.some(file => file.path === data.currentImage.path);
      
      if (!exists) {
        // Ê∑ªÂä†Âà∞ÈÄâÊã©ÁöÑÊñá‰ª∂ÂàóË°®
        selectedFiles.value.push({
          name: data.currentImage.name || 'ÂÖ®ÊôØÂõæ',
          path: data.currentImage.path,
          thumbnail
        });

        // Â¶ÇÊûú‰º†ÂÖ•‰∫ÜÈªòËÆ§ËÆæÁΩÆÔºåÊõ¥Êñ∞ËÆæÁΩÆ
        if (data.settings?.defaultSettings) {
          const defaultSettings = data.settings.defaultSettings;
          if (settingProfiles.value.length > 0) {
            const profile = settingProfiles.value[0];
            
            // Êõ¥Êñ∞ËÆæÁΩÆÔºå‰ªÖÊõ¥Êñ∞Êèê‰æõÁöÑÂÄº
            if (defaultSettings.isLandscape !== undefined) {
              profile.isLandscape = defaultSettings.isLandscape;
            }
            if (defaultSettings.duration !== undefined) {
              profile.duration = defaultSettings.duration;
            }
            if (defaultSettings.fps !== undefined) {
              profile.fps = defaultSettings.fps;
            }
          }
        }
      }
    } catch (error) {
      console.error('Â§ÑÁêÜÊé•Êî∂Âà∞ÁöÑÂõæÂÉèÂ§±Ë¥•:', error);
      showWarningMessage(`Ê∑ªÂä†ÂõæÂÉèÂ§±Ë¥•: ${error.message}`);
    }
  }
};

// ‰ªéÊñá‰ª∂Ë∑ØÂæÑÁîüÊàêÁº©Áï•Âõæ
const generateThumbnailFromPath = async (path) => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 160;
      canvas.height = 90;
      
      // ËÆ°ÁÆóË£ÅÂâ™Âå∫Âüü‰ª•‰øùÊåÅÊØî‰æã
      let sourceWidth = img.width;
      let sourceHeight = img.height;
      let sourceX = 0;
      let sourceY = 0;
      
      if (img.width / img.height > 16 / 9) {
        sourceWidth = img.height * (16 / 9);
        sourceX = (img.width - sourceWidth) / 2;
      } else {
        sourceHeight = img.width * (9 / 16);
        sourceY = (img.height - sourceHeight) / 2;
      }
      
      ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, 160, 90);
      resolve(canvas.toDataURL('image/jpeg', 0.7));
    };
    
    img.onerror = () => {
      reject(new Error('ÁîüÊàêÁº©Áï•ÂõæÂ§±Ë¥•'));
    };
    
    img.src = path;
  });
};

// Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
const cleanupEventListeners = () => {
  // Áî±‰∫é‰∏çÂÜç‰ΩøÁî®‰∫ã‰ª∂ÊÄªÁ∫øÔºåËøôÈáåÂèØ‰ª•Ê∏ÖÁ©∫
};

// ÊñπÊ≥ï
const refreshFileList = () => {
  // ÈáçÊñ∞Âä†ËΩΩÂ∑≤ÈÄâÊñá‰ª∂ÁöÑÁº©Áï•ÂõæÂíå‰ø°ÊÅØ
  selectedFiles.value.forEach(async (file, index) => {
    try {
      if (file.file) {
        // Â¶ÇÊûúÊòØFileÂØπË±°ÔºåÈáçÊñ∞ÁîüÊàêÁº©Áï•Âõæ
        const objectUrl = URL.createObjectURL(file.file);
        const thumbnail = await generateThumbnailFromUrl(objectUrl);
        selectedFiles.value[index].thumbnail = thumbnail;
      } else if (file.path) {
        // Â¶ÇÊûúÊòØÊñá‰ª∂Ë∑ØÂæÑÔºåÂ∞ùËØïÈáçÊñ∞Âä†ËΩΩ
        try {
          const thumbnail = await generateThumbnailFromPath(file.path);
          selectedFiles.value[index].thumbnail = thumbnail;
        } catch (error) {
          console.error('Âà∑Êñ∞Êñá‰ª∂Ë∑ØÂæÑÁº©Áï•ÂõæÂ§±Ë¥•:', error);
        }
      }
    } catch (error) {
      console.error('Âà∑Êñ∞Áº©Áï•ÂõæÂ§±Ë¥•:', error);
    }
  });
};

const showFileSelector = async () => {
  try {
    // Ê∏ÖÁ©∫‰πãÂâçÁöÑÊñá‰ª∂ÂàóË°®
    clearSelectedFiles();
    
    // ‰ΩøÁî®ÊµèËßàÂô®ÂéüÁîüÁöÑÊñá‰ª∂ÈÄâÊã©ÂØπËØùÊ°Ü
    return new Promise((resolve, reject) => {
      // ÂàõÂª∫‰∏Ä‰∏™‰∏¥Êó∂ÁöÑfile inputÂÖÉÁ¥†
      const fileInput = document.createElement('input');
      fileInput.type = 'file';
      fileInput.multiple = true;
      fileInput.accept = '.jpg,.jpeg,.png';
      
      // Â§ÑÁêÜÊñá‰ª∂ÈÄâÊã©‰∫ã‰ª∂
      fileInput.onchange = async (event) => {
        const files = Array.from(event.target.files);
        
        if (files && files.length > 0) {
          try {
            // Â§ÑÁêÜÈÄâÊã©ÁöÑÊñá‰ª∂
            for (const file of files) {
              // ÂàõÂª∫Êú¨Âú∞URLÁî®‰∫éÈ¢ÑËßà
              const objectUrl = URL.createObjectURL(file);
              
              // ÁîüÊàêÁº©Áï•Âõæ
              const thumbnail = await generateThumbnailFromUrl(objectUrl);
              
              // Ê∑ªÂä†Âà∞ÈÄâÊã©ÁöÑÊñá‰ª∂ÂàóË°®
              selectedFiles.value.push({
                name: file.name,
                path: objectUrl, // ‰ΩøÁî®ÂØπË±°URL‰Ωú‰∏∫Ë∑ØÂæÑ
                file: file, // ‰øùÂ≠òÂéüÂßãÊñá‰ª∂ÂØπË±°‰ª•‰æøÂêéÁª≠Â§ÑÁêÜ
                thumbnail
              });
            }
            resolve(files);
          } catch (error) {
            reject(error);
          }
        } else {
          resolve([]);
        }
      };
      
      // Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©ÂØπËØùÊ°Ü
      fileInput.click();
    });
  } catch (error) {
    console.error('ÈÄâÊã©Êñá‰ª∂Â§±Ë¥•:', error);
  }
};

// Â±ïÂºÄ/Êî∂Ëµ∑Ê∞¥Âç∞ËÆæÁΩÆ
const toggleWatermarkExpand = (profileIndex) => {
  settingProfiles.value[profileIndex].watermarkExpanded = !settingProfiles.value[profileIndex].watermarkExpanded;
};

// Ê∑ªÂä†ÈÖçÁΩÆÊñá‰ª∂
const addSettingProfile = () => {
  const newProfile = JSON.parse(JSON.stringify(settingProfiles.value[0]));
  newProfile.watermarkExpanded = false;
  newProfile.previewImage = null;
  settingProfiles.value.push(newProfile);
  
  // ‰∏∫Êñ∞ÈÖçÁΩÆÂàùÂßãÂåñÂ≠ó‰ΩìËøáÊª§
  const newIndex = settingProfiles.value.length - 1;
  filteredFonts[newIndex] = [...availableFonts.value];
  fontSearchQuery[newIndex] = '';
  fontSelectorOpen[newIndex] = false;
};

// ÁßªÈô§ÈÖçÁΩÆÊñá‰ª∂
const removeSettingProfile = (index) => {
  if (settingProfiles.value.length > 1) {
    settingProfiles.value.splice(index, 1);
  }
};

// ‰ªéURLÁîüÊàêÁº©Áï•Âõæ
const generateThumbnailFromUrl = async (url) => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    
    // ËÆæÁΩÆÂ§ÑÁêÜÂáΩÊï∞
    img.onload = () => {
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 160;
      canvas.height = 90;
      
      // ËÆ°ÁÆóË£ÅÂâ™Âå∫Âüü‰ª•‰øùÊåÅÊØî‰æã
      let sourceWidth = img.width;
      let sourceHeight = img.height;
      let sourceX = 0;
      let sourceY = 0;
      
      if (img.width / img.height > 16 / 9) {
        sourceWidth = img.height * (16 / 9);
        sourceX = (img.width - sourceWidth) / 2;
      } else {
        sourceHeight = img.width * (9 / 16);
        sourceY = (img.height - sourceHeight) / 2;
      }
      
      ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, 160, 90);
      const thumbnail = canvas.toDataURL('image/jpeg', 0.7);
      
      // ÈáäÊîæÂØπË±°URL
      URL.revokeObjectURL(url);
      resolve(thumbnail);
    };
    
    img.onerror = () => {
      URL.revokeObjectURL(url); // ÈáäÊîæÂØπË±°URLÔºåÂç≥‰ΩøÂä†ËΩΩÂ§±Ë¥•
      reject(new Error('ÁîüÊàêÁº©Áï•ÂõæÂ§±Ë¥•'));
    };
    
    // ÂºÄÂßãÂä†ËΩΩÂõæÂÉè
    img.src = url;
  });
};

// Ê∑ªÂä†‰∏Ä‰∏™ÊèêÁ§∫‰ø°ÊÅØÁªÑ‰ª∂
const showWarningMessage = (message) => {
  // ÂàõÂª∫ÊèêÁ§∫Ê°Ü
  const warningBox = document.createElement('div');
  warningBox.style.position = 'fixed';
  warningBox.style.top = '20px';
  warningBox.style.left = '50%';
  warningBox.style.transform = 'translateX(-50%)';
  warningBox.style.padding = '15px 20px';
  warningBox.style.backgroundColor = '#fff3cd';
  warningBox.style.color = '#856404';
  warningBox.style.borderRadius = '4px';
  warningBox.style.boxShadow = '0 2px 6px rgba(0,0,0,0.2)';
  warningBox.style.zIndex = '9999';
  warningBox.style.maxWidth = '80%';
  warningBox.style.textAlign = 'center';
  warningBox.textContent = message;
  
  // Ê∑ªÂä†Âà∞ÊñáÊ°£‰∏≠
  document.body.appendChild(warningBox);
  
  // 3ÁßíÂêéËá™Âä®ÁßªÈô§
  setTimeout(() => {
    document.body.removeChild(warningBox);
  }, 5000);
};

const removeFile = (index) => {
  selectedFiles.value.splice(index, 1);
};

const clearSelectedFiles = () => {
  selectedFiles.value = [];
};

const selectOutputDir = async () => {
  try {
    // Â¢ûÂº∫ElectronÁéØÂ¢ÉÊ£ÄÊµã
    const isElectronEnv = !!(window.electron || 
                           (window.require && window.require('electron')) || 
                           window.process?.versions?.electron);
    
    if (isElectronEnv) {
      // Á°Æ‰øùËé∑ÂèñelectronÂØπË±°
      const electron = window.electron || 
                      (window.require ? window.require('electron') : null);
      
      if (electron) {
        console.log('‰ΩøÁî®Electron APIÈÄâÊã©ÁõÆÂΩï');
        // ‰ΩøÁî®ElectronÁöÑÂØπËØùÊ°ÜAPI
        try {
          const dialog = window.require('@electron/remote').dialog;
          const result = await dialog.showOpenDialog({
            properties: ['openDirectory'],
            title: 'ÈÄâÊã©ËæìÂá∫ÁõÆÂΩï'
          });
          
          if (result && !result.canceled && result.filePaths && result.filePaths.length > 0) {
            outputDir.value = result.filePaths[0];
            console.log('Â∑≤ÈÄâÊã©ÁõÆÂΩï:', outputDir.value);
          }
          return;
        } catch (electronErr) {
          console.error('ElectronÂØπËØùÊ°ÜÈîôËØØ:', electronErr);
          // Â¶ÇÊûúElectronÊñπÊ≥ïÂ§±Ë¥•ÔºåÂõûÈÄÄÂà∞ÊâãÂä®ËæìÂÖ•
        }
      }
    }
    
    // ÂõûÈÄÄÂà∞ÊâãÂä®ËæìÂÖ•ÊñπÂºè
    console.log('‰ΩøÁî®ÊâãÂä®ËæìÂÖ•ÊñπÂºè');
    // ÂàõÂª∫‰∏Ä‰∏™ËæìÂÖ•Ê°Ü
    const input = document.createElement('input');
    input.type = 'text';
    input.value = outputDir.value || 'ÂÖ®ÊôØËßÜÈ¢ëÂØºÂá∫';
    input.style.position = 'fixed';
    input.style.left = '50%';
    input.style.top = '50%';
    input.style.transform = 'translate(-50%, -50%)';
    input.style.zIndex = '9999';
    input.style.padding = '10px';
    input.style.border = '1px solid #ccc';
    
    // ÂàõÂª∫‰∏Ä‰∏™ÊåâÈíÆ
    const button = document.createElement('button');
    button.textContent = 'Á°ÆÂÆö';
    button.style.marginLeft = '10px';
    button.style.padding = '10px';
    
    // ÂàõÂª∫‰∏Ä‰∏™ÂÆπÂô®
    const container = document.createElement('div');
    container.style.position = 'fixed';
    container.style.left = '0';
    container.style.top = '0';
    container.style.width = '100%';
    container.style.height = '100%';
    container.style.backgroundColor = 'rgba(0,0,0,0.5)';
    container.style.display = 'flex';
    container.style.alignItems = 'center';
    container.style.justifyContent = 'center';
    container.style.zIndex = '9998';
    
    const inputContainer = document.createElement('div');
    inputContainer.style.backgroundColor = 'white';
    inputContainer.style.padding = '20px';
    inputContainer.style.borderRadius = '5px';
    inputContainer.style.display = 'flex';
    inputContainer.style.flexDirection = 'column';
    inputContainer.style.gap = '10px';
    
    const label = document.createElement('div');
    label.textContent = 'ËØ∑ËæìÂÖ•ËæìÂá∫ÁõÆÂΩïÂêçÁß∞:';
    
    const buttonContainer = document.createElement('div');
    buttonContainer.style.display = 'flex';
    buttonContainer.style.justifyContent = 'flex-end';
    buttonContainer.appendChild(button);
    
    inputContainer.appendChild(label);
    inputContainer.appendChild(input);
    inputContainer.appendChild(buttonContainer);
    container.appendChild(inputContainer);
    
    document.body.appendChild(container);
    
    // ËÅöÁÑ¶Âà∞ËæìÂÖ•Ê°Ü
    input.focus();
    
    return new Promise((resolve) => {
      // ÁÇπÂáªÁ°ÆÂÆöÊåâÈíÆÊó∂
      button.onclick = () => {
        const value = input.value.trim();
        if (value) {
          outputDir.value = value;
        }
        document.body.removeChild(container);
        resolve();
      };
      
      // ÁÇπÂáªËÉåÊôØÊó∂ÂÖ≥Èó≠
      container.onclick = (e) => {
        if (e.target === container) {
          document.body.removeChild(container);
          resolve();
        }
      };
      
      // ÊåâESCÈîÆÂÖ≥Èó≠
      window.addEventListener('keydown', function handler(e) {
        if (e.key === 'Escape') {
          document.body.removeChild(container);
          window.removeEventListener('keydown', handler);
          resolve();
        }
        if (e.key === 'Enter') {
          button.click();
          window.removeEventListener('keydown', handler);
        }
      });
    });
  } catch (error) {
    console.error('ÈÄâÊã©ËæìÂá∫ÁõÆÂΩïÂ§±Ë¥•:', error);
    showWarningMessage(`ÈÄâÊã©ËæìÂá∫ÁõÆÂΩïÂ§±Ë¥•: ${error.message}`);
  }
};

const startBatchExport = async () => {
  if (!canStartExport.value) return;
  
  // Ê£ÄÊü•ÊòØÂê¶ÊúâÊñá‰ª∂ÂØπË±°
  const hasFileObjects = selectedFiles.value.every(file => file.file instanceof File);
  if (!hasFileObjects) {
    showWarningMessage('ËØ∑‰ΩøÁî®"ÊµèËßàÊñá‰ª∂"ÊåâÈíÆÈáçÊñ∞ÈÄâÊã©Êñá‰ª∂ÔºåÂõ†‰∏∫ÂΩìÂâçÈÄâÊã©ÁöÑÊñá‰ª∂Êó†Ê≥ïÂú®ÊµèËßàÂô®ÁéØÂ¢É‰∏≠Áõ¥Êé•ËÆøÈóÆ„ÄÇ');
    // Ê∏ÖÁ©∫ÂΩìÂâçÈÄâÊã©ÁöÑÊñá‰ª∂
    clearSelectedFiles();
    return;
  }
  
  isExporting.value = true;
  currentTaskIndex.value = -1;
  
  // ÂàõÂª∫‰ªªÂä°ÂàóË°® - ‰∏∫ÊØè‰∏™Êñá‰ª∂ÂíåÊØè‰∏™ÈÖçÁΩÆÂàõÂª∫‰ªªÂä°
  tasks.value = [];
  
  for (const file of selectedFiles.value) {
    for (let profileIndex = 0; profileIndex < settingProfiles.value.length; profileIndex++) {
      tasks.value.push({
        fileName: file.name,
        filePath: file.path,
        file: file.file,
        profileIndex: profileIndex,
        profile: settingProfiles.value[profileIndex],
        outputPath: '',
        progress: 0,
        status: 'pending',
        stage: '',
        currentFrame: 0,
        totalFrames: 0
      });
    }
  }
  
  // ÂºÄÂßãÂ§ÑÁêÜ‰ªªÂä°
  processNextTask();
};

const processNextTask = async () => {
  currentTaskIndex.value++;
  
  if (currentTaskIndex.value >= tasks.value.length) {
    // ÊâÄÊúâ‰ªªÂä°ÂÆåÊàê
    isExporting.value = false;
    return;
  }
  
  const currentTask = tasks.value[currentTaskIndex.value];
  currentTask.status = 'processing';
  currentTask.stage = 'ÂáÜÂ§á‰∏≠';
  
  try {
    // Ëé∑ÂèñÂΩìÂâç‰ªªÂä°ÁöÑÈÖçÁΩÆ
    const profile = currentTask.profile;
    
    // Ëé∑ÂèñÂàÜËæ®Áéá
    let width, height;
    switch(profile.resolution) {
      case '4k':
        width = profile.isLandscape ? 3840 : 2160;
        height = profile.isLandscape ? 2160 : 3840;
        break;
      case '2k':
        width = profile.isLandscape ? 2560 : 1440;
        height = profile.isLandscape ? 1440 : 2560;
        break;
      default: // 1080p
        width = profile.isLandscape ? 1920 : 1080;
        height = profile.isLandscape ? 1080 : 1920;
    }
    
    // ÂàõÂª∫Êñá‰ª∂Âêç
    const baseName = currentTask.fileName.substring(0, currentTask.fileName.lastIndexOf('.')) || currentTask.fileName;
    // ÈÖçÁΩÆÂêéÁºÄÔºåÂ¶ÇÊûúÊúâÂ§ö‰∏™ÈÖçÁΩÆÂàôÊ∑ªÂä†ÈÖçÁΩÆÁºñÂè∑
    const configSuffix = settingProfiles.value.length > 1 ? `_ÈÖçÁΩÆ${currentTask.profileIndex + 1}` : '';
    const outputFileName = `${baseName}${configSuffix}_${width}x${height}_${profile.duration}s.mp4`;
    
    // Á°ÆÂÆöËæìÂá∫ÁõÆÂΩïÂíåÊñá‰ª∂Âêç
    let folderName = createSubDirs.value ? baseName : '';
    currentTask.outputPath = folderName ? `${folderName}/${outputFileName}` : outputFileName;
    
    currentTask.stage = 'Âä†ËΩΩÂõæÂÉè';
    
    // ‰ªéFileÂØπË±°ÂàõÂª∫Á∫πÁêÜ
    const texture = await new Promise((resolve, reject) => {
      // ÂàõÂª∫‰∏Ä‰∏™ÂõæÂÉèÂØπË±°
      const img = new Image();
      
      // ‰ªéFileÂØπË±°ÂàõÂª∫URL
      const objectUrl = URL.createObjectURL(currentTask.file);
      
      // ËÆæÁΩÆÂ§ÑÁêÜÂáΩÊï∞
      img.onload = () => {
        // ÂàõÂª∫Three.jsÁ∫πÁêÜ
        const texture = new THREE.Texture(img);
        texture.needsUpdate = true;
        URL.revokeObjectURL(objectUrl); // ÈáäÊîæÂØπË±°URL
        resolve(texture);
      };
      
      img.onerror = () => {
        URL.revokeObjectURL(objectUrl); // ÈáäÊîæÂØπË±°URLÔºåÂç≥‰ΩøÂä†ËΩΩÂ§±Ë¥•
        reject(new Error(`Êó†Ê≥ïÂä†ËΩΩÂõæÁâá: ${currentTask.fileName}`));
      };
      
      // ÂºÄÂßãÂä†ËΩΩÂõæÂÉè
      img.src = objectUrl;
    });
    
    currentTask.stage = 'ËÆæÁΩÆÂú∫ÊôØ';
    
    // ÂàõÂª∫ËßÜÈ¢ëÁîüÊàêÂô®
    const generator = new PanoramaVideoGenerator(width, height);
    await generator.setupScene(texture);
    
    // Â§ÑÁêÜÊ∞¥Âç∞
    const watermarkOptions = prepareWatermarkOptions(profile, width);
    
    // Â¶ÇÊûúÊúâÂõæÁâáÊ∞¥Âç∞ÔºåÂä†ËΩΩÂõæÁâá
    if (watermarkOptions.image && watermarkOptions.image.enabled && profile.watermark.image.file) {
      try {
        await generator.setImageWatermark({
          imageUrl: profile.watermark.image.preview,
          position: watermarkOptions.image.position,
          width: watermarkOptions.image.width,
          opacity: watermarkOptions.image.opacity
        });
      } catch (error) {
        console.error('ËÆæÁΩÆÂõæÁâáÊ∞¥Âç∞Â§±Ë¥•:', error);
        // ÁªßÁª≠Â§ÑÁêÜÔºåÂç≥‰ΩøËÆæÁΩÆÂõæÁâáÊ∞¥Âç∞Â§±Ë¥•
      }
    }
    
    // ËÆæÁΩÆÊñáÂ≠óÊ∞¥Âç∞
    if (watermarkOptions.text && watermarkOptions.text.enabled) {
      generator.setTextWatermark(watermarkOptions.text);
    }
    
    // ËÆæÁΩÆËøõÂ∫¶ÂõûË∞É
    generator.setProgressCallback(({ progress, currentFrame, totalFrames, stage }) => {
      currentTask.progress = progress;
      currentTask.stage = stage || 'Ê∏≤Êüì‰∏≠';
      currentTask.currentFrame = currentFrame;
      currentTask.totalFrames = totalFrames;
      // Âä®ÊÄÅÊõ¥Êñ∞‰ªªÂä°Áä∂ÊÄÅ
      tasks.value = [...tasks.value];
    });
    
    currentTask.stage = 'ÂºÄÂßãÂΩïÂà∂';
    
    // ÂºÄÂßãÂΩïÂà∂
    const videoBlob = await generator.startRecording({
      duration: profile.duration,
      fps: profile.fps,
      startLon: 0,
      endLon: 360 * profile.rotations,
      startLat: 0,
      endLat: 0,
      width,
      height,
      smoothness: profile.smoothness,
      rotations: profile.rotations,
      watermarkOptions
    });
    
    currentTask.stage = '‰øùÂ≠òËßÜÈ¢ë';
    
    // ‰ΩøÁî®ÊµèËßàÂô®ÁöÑ‰∏ãËΩΩAPI‰øùÂ≠òËßÜÈ¢ë
    const url = URL.createObjectURL(videoBlob);
    
    // ÂàõÂª∫‰∏ãËΩΩÈìæÊé•
    const a = document.createElement('a');
    a.href = url;
    a.download = currentTask.outputPath; // ‰ΩøÁî®‰πãÂâçÊûÑÂª∫ÁöÑË∑ØÂæÑ‰Ωú‰∏∫Êñá‰ª∂Âêç
    document.body.appendChild(a);
    a.click();
    
    // Ê∏ÖÁêÜ
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
    
    // Êõ¥Êñ∞‰ªªÂä°Áä∂ÊÄÅ
    currentTask.status = 'completed';
    currentTask.progress = 1;
    currentTask.stage = 'Â∑≤ÂÆåÊàê';
    tasks.value = [...tasks.value];
    
    // Â§ÑÁêÜ‰∏ã‰∏Ä‰∏™‰ªªÂä°
    processNextTask();
  } catch (error) {
    console.error('Â§ÑÁêÜ‰ªªÂä°Â§±Ë¥•:', error);
    currentTask.status = 'error';
    currentTask.error = error.message;
    currentTask.stage = 'Âá∫Èîô';
    tasks.value = [...tasks.value];
    
    // ÁªßÁª≠Â§ÑÁêÜ‰∏ã‰∏Ä‰∏™‰ªªÂä°
    processNextTask();
  }
};

// ÂáÜÂ§áÊ∞¥Âç∞ÈÄâÈ°π
const prepareWatermarkOptions = (profile, videoWidth) => {
  const options = {
    text: null,
    image: null
  };
  
  // Â§ÑÁêÜÊñáÂ≠óÊ∞¥Âç∞
  if (profile.watermark.text.enabled) {
    // Ê†πÊçÆÈÄâÊã©ÁöÑÂ≠ó‰ΩìÂ§ßÂ∞èÔºåËÆ°ÁÆóÂÆûÈôÖÂÉèÁ¥†ÂÄº
    let fontSize;
    switch (profile.watermark.text.fontSize) {
      case 'small':
        fontSize = Math.max(16, videoWidth / 60);
        break;
      case 'large':
        fontSize = Math.max(32, videoWidth / 30);
        break;
      case 'medium':
      default:
        fontSize = Math.max(24, videoWidth / 45);
    }
    
    options.text = {
      enabled: true,
      text: profile.watermark.text.text,
      position: profile.watermark.text.position,
      font: `${Math.round(fontSize)}px ${profile.watermark.text.fontFamily}`,
      color: profile.watermark.text.color
    };
  }
  
  // Â§ÑÁêÜÂõæÁâáÊ∞¥Âç∞
  if (profile.watermark.image.enabled && profile.watermark.image.preview) {
    options.image = {
      enabled: true,
      position: profile.watermark.image.position,
      width: profile.watermark.image.size, // ‰ΩøÁî®ÁôæÂàÜÊØîË°®Á§∫ÁöÑÂ∞∫ÂØ∏
      opacity: profile.watermark.image.opacity
    };
  }
  
  return options;
};

// Êõ¥Êñ∞ÊñáÂ≠óÊ∞¥Âç∞È¢úËâ≤ (ÁªìÂêàÈ¢úËâ≤ÈÄâÊã©Âô®ÂíåÈÄèÊòéÂ∫¶ÊªëÂùó)
const updateTextWatermarkColor = (profileIndex) => {
  const profile = settingProfiles.value[profileIndex];
  const hex = profile.watermark.text.colorHex;
  const opacity = profile.watermark.text.opacity;
  
  // Â∞ÜÂçÅÂÖ≠ËøõÂà∂È¢úËâ≤ËΩ¨Êç¢‰∏∫RGB
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  
  // ÁîüÊàêrgbaÈ¢úËâ≤Â≠óÁ¨¶‰∏≤
  profile.watermark.text.color = `rgba(${r}, ${g}, ${b}, ${opacity})`;
};

// ÈÄâÊã©Ê∞¥Âç∞ÂõæÁâá
const selectWatermarkImage = (profileIndex) => {
  // ÂàõÂª∫‰∏¥Êó∂Êñá‰ª∂ÈÄâÊã©ÂÖÉÁ¥†
  const fileInput = document.createElement('input');
  fileInput.type = 'file';
  fileInput.accept = 'image/*';
  
  fileInput.onchange = async (event) => {
    const file = event.target.files[0];
    if (file) {
      // ‰ΩøÁî®ObjectURLÂàõÂª∫È¢ÑËßà
      const preview = URL.createObjectURL(file);
      
      // Êõ¥Êñ∞ÈÖçÁΩÆ
      settingProfiles.value[profileIndex].watermark.image.file = file;
      settingProfiles.value[profileIndex].watermark.image.preview = preview;
    }
  };
  
  // Ëß¶ÂèëÊñá‰ª∂ÈÄâÊã©
  fileInput.click();
};

const getTaskStatusText = (task) => {
  switch (task.status) {
    case 'pending':
      return 'Á≠âÂæÖ‰∏≠';
    case 'processing':
      if (task.stage) {
        return `${task.stage}...`;
      }
      return 'Â§ÑÁêÜ‰∏≠...';
    case 'completed':
      return 'Â∑≤ÂÆåÊàê';
    case 'error':
      return `ÈîôËØØ: ${task.error || 'Êú™Áü•ÈîôËØØ'}`;
    default:
      return 'Êú™Áü•Áä∂ÊÄÅ';
  }
};

onMounted(() => {
  console.log('ÊâπÈáèÂØºÂá∫Âô®ÁªÑ‰ª∂Â∑≤ÊåÇËΩΩ');
  
  // Êâ©Â±ï PanoramaVideoGenerator
  if (PanoramaVideoGenerator.prototype) {
    // Êâ©Â±ïÊ∏≤ÊüìÂçïÂ∏ßÁöÑÊñπÊ≥ï
    PanoramaVideoGenerator.prototype.renderFrame = async function(options) {
      const { lon, lat, width, height } = options;
      
      // ËÆæÁΩÆÁõ∏Êú∫‰ΩçÁΩÆ
      this.camera.position.set(0, 0, 0);
      this.camera.rotation.set(0, 0, 0);
      
      // ÊóãËΩ¨Áõ∏Êú∫Âà∞ÊåáÂÆöÁªèÁ∫¨Â∫¶
      this.camera.rotateY(THREE.MathUtils.degToRad(lon));
      this.camera.rotateX(THREE.MathUtils.degToRad(lat));
      
      // ÂàõÂª∫Ê∏≤ÊüìÂô®Âπ∂Á°Æ‰øùÊäóÈîØÈΩøÂíåÈÄèÊòéÂ∫¶ÊîØÊåÅ
      if (!this.renderer) {
        this.renderer = new THREE.WebGLRenderer({ 
          antialias: true,
          alpha: true,
          preserveDrawingBuffer: true
        });
        this.renderer.setSize(width || this.width, height || this.height);
        this.renderer.setClearColor(0x000000, 0);
      }
      
      // Á°Æ‰øùÊ∞¥Âç∞Â±ÇÂú®Âú∫ÊôØ‰∏≠Âπ∂ÂèØËßÅ
      if (this.watermarkText) {
        this.watermarkText.visible = true;
        this.watermarkText.renderOrder = 999;
        if (!this.scene.getObjectById(this.watermarkText.id)) {
          this.scene.add(this.watermarkText);
        }
      }
      
      if (this.watermarkImage) {
        this.watermarkImage.visible = true;
        this.watermarkImage.renderOrder = 999;
        if (!this.scene.getObjectById(this.watermarkImage.id)) {
          this.scene.add(this.watermarkImage);
        }
      }
      
      // Ê∏≤ÊüìÂú∫ÊôØ
      this.renderer.render(this.scene, this.camera);
      
      // ËøîÂõûCanvasÂÖÉÁ¥†
      return this.renderer.domElement;
    };
    
    // Ê£ÄÊü•Âπ∂Êâ©Â±ïËÆæÁΩÆÊñáÂ≠óÊ∞¥Âç∞ÁöÑÊñπÊ≥ï
    if (PanoramaVideoGenerator.prototype.setTextWatermark) {
      const originalSetTextWatermark = PanoramaVideoGenerator.prototype.setTextWatermark;
      PanoramaVideoGenerator.prototype.setTextWatermark = function(options) {
        console.log('Â¢ûÂº∫ÁöÑsetTextWatermarkË¢´Ë∞ÉÁî®', options);
        // Ë∞ÉÁî®ÂéüÂßãÊñπÊ≥ï
        const result = originalSetTextWatermark.call(this, options);
        
        // Á°Æ‰øùÊñáÂ≠óÊ∞¥Âç∞ÊòØÂèØËßÅÁöÑ
        if (this.watermarkText) {
          this.watermarkText.visible = true;
          this.watermarkText.renderOrder = 999;
          console.log('ÊñáÂ≠óÊ∞¥Âç∞Â∑≤ËÆæÁΩÆ‰∏∫ÂèØËßÅ');
        } else {
          console.warn('ÊñáÂ≠óÊ∞¥Âç∞Êú™ÂàõÂª∫');
        }
        
        return result;
      };
    }
    
    // Ê∑ªÂä†ËµÑÊ∫êÈáäÊîæÊñπÊ≥ï
    if (!PanoramaVideoGenerator.prototype.dispose) {
      PanoramaVideoGenerator.prototype.dispose = function() {
        if (this.renderer) {
          this.renderer.dispose();
          this.renderer = null;
        }
        
        // Ê∏ÖÁêÜÂú∫ÊôØ‰∏≠ÁöÑÂØπË±°
        if (this.scene) {
          while(this.scene.children.length > 0) { 
            this.scene.remove(this.scene.children[0]); 
          }
        }
        
        // Ê∏ÖÁêÜÁ∫πÁêÜ
        if (this.panoramaTexture) {
          this.panoramaTexture.dispose();
          this.panoramaTexture = null;
        }
        
        this.camera = null;
        this.scene = null;
        this.watermarkText = null;
        this.watermarkImage = null;
      };
    }
  }
  
  // Âä†ËΩΩÁ≥ªÁªüÂ≠ó‰Ωì
  loadSystemFonts();
  
  // ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô®
  setupEventListeners();
});

onUnmounted(() => {
  // Ê∏ÖÁêÜÈ¢ÑËßàÂô®ÁºìÂ≠ò
  Object.values(previewerCache.value).forEach(item => {
    if (item.previewer && item.previewer.dispose) {
      item.previewer.dispose();
    }
  });
  previewerCache.value = {};
  
  // Ê∏ÖÁêÜ‰∫ã‰ª∂ÁõëÂê¨Âô®
  cleanupEventListeners();
});
</script>

<style scoped>
.batch-exporter-container {
  height: 100%;
  width: 100%;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  background: var(--cc-theme-background);
  color: var(--cc-theme-on-background);
}

.panel-header {
  padding: 16px;
  border-bottom: 1px solid var(--cc-border-color);
  display: flex;
  align-items: center;
  justify-content: space-between;
}

.panel-header h2 {
  margin: 0;
  font-size: 18px;
  font-weight: 500;
}

.panel-body {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  display: flex;
  flex-direction: column;
  gap: 24px;
}

.section {
  background: var(--cc-theme-surface);
  border-radius: 8px;
  border: 1px solid var(--cc-border-color);
}

.section-header {
  padding: 12px 16px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-bottom: 1px solid var(--cc-border-color);
}

.section-header h3 {
  margin: 0;
  font-size: 16px;
  font-weight: 500;
}

.header-actions, .panel-actions {
  display: flex;
  gap: 8px;
}

.action-btn {
  padding: 6px 12px;
  background: var(--cc-theme-surface-light);
  border: 1px solid var(--cc-border-color);
  border-radius: 4px;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 4px;
  font-size: 14px;
}

.action-btn:hover {
  background: var(--cc-theme-surface-hover);
}

.action-btn.primary {
  background: var(--cc-theme-primary);
  color: white;
  border-color: var(--cc-theme-primary);
}

.action-btn.primary:hover {
  background: var(--cc-theme-primary-hover);
}

.action-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.action-btn.small {
  padding: 4px 8px;
  font-size: 12px;
}

.file-list-container {
  padding: 16px;
  max-height: 300px;
  overflow-y: auto;
}

.empty-tip {
  padding: 32px;
  text-align: center;
  color: var(--cc-theme-on-surface-variant);
}

.file-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.file-item {
  display: flex;
  gap: 12px;
  padding: 8px;
  border-radius: 4px;
  background: var(--cc-theme-surface-light);
  align-items: center;
}

.file-preview {
  width: 80px;
  height: 45px;
  overflow: hidden;
  border-radius: 4px;
  flex-shrink: 0;
}

.file-preview img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.file-info {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.file-name {
  font-weight: 500;
}

.file-path {
  font-size: 12px;
  color: var(--cc-theme-on-surface-variant);
  word-break: break-all;
}

.settings-profiles-container {
  display: flex;
  flex-direction: column;
  gap: 16px;
  padding: 16px;
}

.setting-profile {
  border: 1px solid var(--cc-border-color);
  border-radius: 4px;
  overflow: hidden;
}

.profile-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 12px;
  background: var(--cc-theme-surface-light);
  border-bottom: 1px solid var(--cc-border-color);
}

.profile-header h4 {
  margin: 0;
  font-size: 14px;
  font-weight: 500;
}

.profile-actions {
  display: flex;
  gap: 8px;
}

.settings-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
  gap: 16px;
  padding: 16px;
}

.setting-group {
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.setting-item {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.setting-item label {
  font-size: 14px;
  font-weight: 500;
}

.setting-item select,
.setting-item input[type="text"] {
  padding: 8px 12px;
  border-radius: 4px;
  border: 1px solid var(--cc-border-color);
  background: var(--cc-theme-surface-light);
  width: 100%;
}

.setting-item input[type="text"] {
  font-size: 14px;
}

.setting-item input[type="range"] {
  width: 100%;
}

.output-path-selector {
  display: flex;
  gap: 8px;
}

.output-path-selector input {
  flex: 1;
}

.checkbox-wrapper {
  display: flex;
  align-items: center;
  gap: 8px;
}

.range-value {
  text-align: center;
  font-size: 12px;
  color: var(--cc-theme-on-surface-variant);
}

.tasks-container {
  padding: 16px;
  max-height: 300px;
  overflow-y: auto;
}

.task-list {
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.task-item {
  padding: 12px;
  border-radius: 4px;
  background: var(--cc-theme-surface-light);
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.task-item.task-completed {
  border-left: 3px solid var(--cc-theme-success);
}

.task-item.task-error {
  border-left: 3px solid var(--cc-theme-error);
}

.task-info {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.task-name {
  font-weight: 500;
  display: flex;
  align-items: center;
  gap: 8px;
}

.profile-badge {
  font-size: 12px;
  padding: 2px 6px;
  background-color: var(--cc-theme-secondary);
  color: white;
  border-radius: 10px;
}

.task-status {
  font-size: 12px;
  color: var(--cc-theme-on-surface-variant);
}

.progress-bar {
  height: 8px;
  background: rgba(0, 0, 0, 0.1);
  border-radius: 4px;
  overflow: hidden;
  position: relative;
}

.progress-fill {
  height: 100%;
  background: var(--cc-theme-primary);
  border-radius: 4px;
  transition: width 0.3s linear;
}

.task-progress {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.progress-details {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
}

.progress-value {
  font-weight: 500;
}

.stage-info {
  color: var(--cc-theme-on-surface-variant);
}

.overall-progress {
  padding: 16px;
  border-top: 1px solid var(--cc-border-color);
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.progress-info {
  display: flex;
  justify-content: space-between;
  font-size: 14px;
}

.icon {
  display: inline-block;
  width: 20px;
  text-align: center;
}

.refresh-btn {
  padding: 4px 8px;
}

/* Ê∑ªÂä†Ê∞¥Âç∞ËÆæÁΩÆÊ†∑Âºè */
.watermark-settings {
  border-top: 1px solid var(--cc-border-color);
  margin-top: 16px;
  padding-top: 8px;
}

.watermark-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 8px 16px;
}

.watermark-header h4 {
  margin: 0;
  font-size: 14px;
  font-weight: 500;
}

.expand-toggle {
  font-size: 12px;
  color: var(--cc-theme-primary);
  cursor: pointer;
}

.watermark-content {
  padding: 0 16px 16px;
  animation: slideDown 0.3s ease;
}

@keyframes slideDown {
  from { opacity: 0; transform: translateY(-10px); }
  to { opacity: 1; transform: translateY(0); }
}

.watermark-section {
  margin-bottom: 16px;
  border: 1px solid var(--cc-border-color);
  border-radius: 4px;
  overflow: hidden;
}

.section-title {
  font-size: 13px;
  font-weight: 500;
}

.section-toggle {
  display: flex;
  align-items: center;
  gap: 4px;
}

.watermark-options {
  padding: 12px;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.image-selector {
  display: flex;
  gap: 12px;
  align-items: center;
}

.image-preview {
  width: 80px;
  height: 45px;
  overflow: hidden;
  border-radius: 4px;
  border: 1px solid var(--cc-border-color);
}

.image-preview img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

.color-picker {
  display: flex;
  gap: 16px;
  align-items: center;
}

.color-picker input[type="color"] {
  width: 40px;
  height: 36px;
  border: 1px solid var(--cc-border-color);
  border-radius: 4px;
  cursor: pointer;
}

.transparency-slider {
  flex: 1;
}

.range-with-value {
  display: flex;
  align-items: center;
  gap: 12px;
}

.range-with-value input[type="range"] {
  flex: 1;
}

/* Â≠ó‰ΩìÈÄâÊã©Âô®Ê†∑Âºè */
.font-selector {
  position: relative;
  width: 100%;
}

.font-selector-header {
  padding: 8px 12px;
  border: 1px solid var(--cc-border-color);
  border-radius: 4px;
  background: var(--cc-theme-surface-light);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.font-selector-dropdown {
  position: absolute;
  width: 100%;
  max-height: 300px;
  background: var(--cc-theme-surface);
  border: 1px solid var(--cc-border-color);
  border-radius: 4px;
  margin-top: 4px;
  z-index: 10;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
}

.font-search {
  padding: 8px;
  border-bottom: 1px solid var(--cc-border-color);
}

.font-search input {
  width: 100%;
  padding: 8px;
  border: 1px solid var(--cc-border-color);
  border-radius: 4px;
}

.font-list {
  overflow-y: auto;
  max-height: 240px;
}

.font-item {
  padding: 8px 12px;
  cursor: pointer;
  transition: background-color 0.2s;
}

.font-item:hover {
  background-color: var(--cc-theme-surface-hover);
}

.font-item.selected {
  background-color: var(--cc-theme-primary-light);
}

.font-preview-area {
  margin-top: 12px;
  padding: 12px;
  border: 1px solid var(--cc-border-color);
  border-radius: 4px;
  background-color: var(--cc-theme-surface-light);
}

.preview-label {
  font-size: 12px;
  margin-bottom: 8px;
  color: var(--cc-theme-on-surface-variant);
}

.font-preview {
  min-height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  padding: 8px;
  background-color: rgba(0, 0, 0, 0.05);
  border-radius: 4px;
  word-break: break-word;
}

/* Ê∞¥Âç∞Â∏ÉÂ±ÄÊ†∑Âºè */
.watermark-layout {
  display: flex;
  gap: 16px;
  flex-wrap: wrap;
}

.watermark-options-column {
  flex: 1;
  min-width: 300px;
}

.watermark-preview-column {
  flex: 1;
  min-width: 300px;
  display: flex;
  flex-direction: column;
}

.watermark-preview-section {
  height: 100%;
  border: 1px solid var(--cc-border-color);
  border-radius: 4px;
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

.preview-container {
  padding: 16px;
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
}

.empty-preview {
  height: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--cc-theme-on-surface-variant);
  text-align: center;
  background: rgba(0, 0, 0, 0.05);
  width: 100%;
  border-radius: 4px;
  position: relative;
}

.empty-preview > div {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100%;
  padding: 0 10px;
}

.frame-preview {
  max-width: 100%;
  text-align: center;
}

.frame-preview img {
  max-width: 100%;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

/* ÂìçÂ∫îÂºèË∞ÉÊï¥ */
@media (max-width: 768px) {
  .watermark-layout {
    flex-direction: column;
  }
  
  .watermark-preview-column,
  .watermark-options-column {
    width: 100%;
  }
}

/* Ê∑ªÂä†ÈîôËØØ‰ø°ÊÅØÊ†∑Âºè */
.preview-error {
  height: auto;
  min-height: 150px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  color: #721c24;
  background-color: #f8d7da;
  border: 1px solid #f5c6cb;
  border-radius: 4px;
  padding: 16px;
  width: 100%;
  text-align: center;
}

.error-icon {
  font-size: 24px;
  margin-bottom: 8px;
}

.error-message {
  word-break: break-word;
  font-size: 13px;
}
</style> 