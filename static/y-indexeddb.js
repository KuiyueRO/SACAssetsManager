import*as c from"./yjs.js";var i=e=>new Promise(e);var C=Promise.all.bind(Promise);var _=e=>new Error(e);var a=e=>i((t,o)=>{e.onerror=r=>o(new Error(r.target.error)),e.onsuccess=r=>t(r.target.result)}),g=(e,t)=>i((o,r)=>{let s=indexedDB.open(e);s.onupgradeneeded=n=>t(n.target.result),s.onerror=n=>r(_(n.target.error)),s.onsuccess=n=>{let p=n.target.result;p.onversionchange=()=>{p.close()},o(p)}}),f=e=>a(indexedDB.deleteDatabase(e)),v=(e,t)=>t.forEach(o=>e.createObjectStore.apply(e,o)),d=(e,t,o="readwrite")=>{let r=e.transaction(t,o);return t.map(s=>L(r,s))},m=(e,t)=>a(e.count(t)),A=(e,t)=>a(e.get(t)),x=(e,t)=>a(e.delete(t)),I=(e,t,o)=>a(e.put(t,o));var l=(e,t)=>a(e.add(t)),T=(e,t,o)=>a(e.getAll(t,o));var Y=(e,t,o)=>{let r=null;return F(e,t,s=>(r=s,!1),o).then(()=>r)},w=(e,t=null)=>Y(e,t,"prev");var q=(e,t)=>i((o,r)=>{e.onerror=r,e.onsuccess=async s=>{let n=s.target.result;if(n===null||await t(n)===!1)return o();n.continue()}});var F=(e,t,o,r="next")=>q(e.openKeyCursor(t,r),s=>o(s.key)),L=(e,t)=>e.objectStore(t);var B=(e,t)=>IDBKeyRange.upperBound(e,t),U=(e,t)=>IDBKeyRange.lowerBound(e,t);var u=()=>new Map;var K=(e,t,o)=>{let r=e.get(t);return r===void 0&&e.set(t,r=o()),r};var D=()=>new Set;var E=Array.from;var Z=Array.isArray;var h=class{constructor(){this._observers=u()}on(t,o){K(this._observers,t,D).add(o)}once(t,o){let r=(...s)=>{this.off(t,r),o(...s)};this.on(t,r)}off(t,o){let r=this._observers.get(t);r!==void 0&&(r.delete(o),r.size===0&&this._observers.delete(t))}emit(t,o){return E((this._observers.get(t)||u()).values()).forEach(r=>r(...o))}destroy(){this._observers=u()}};var y="custom",R="updates",k=500,z=(e,t=()=>{},o=()=>{})=>{let[r]=d(e.db,[R]);return T(r,U(e._dbref,!1)).then(s=>{e._destroyed||(t(r),c.transact(e.doc,()=>{s.forEach(n=>c.applyUpdate(e.doc,n))},e,!1),o(r))}).then(()=>w(r).then(s=>{e._dbref=s+1})).then(()=>m(r).then(s=>{e._dbsize=s})).then(()=>r)},W=(e,t=!0)=>z(e).then(o=>{(t||e._dbsize>=k)&&l(o,c.encodeStateAsUpdate(e.doc)).then(()=>x(o,B(e._dbref,!0))).then(()=>m(o).then(r=>{e._dbsize=r}))}),Q=e=>f(e),S=class extends h{constructor(t,o){super(),this.doc=o,this.name=t,this._dbref=0,this._dbsize=0,this._destroyed=!1,this.db=null,this.synced=!1,this._db=g(t,r=>v(r,[["updates",{autoIncrement:!0}],["custom"]])),this.whenSynced=i(r=>this.on("synced",()=>r(this))),this._db.then(r=>{this.db=r,z(this,p=>l(p,c.encodeStateAsUpdate(o)),()=>{if(this._destroyed)return this;this.synced=!0,this.emit("synced",[this])})}),this._storeTimeout=1e3,this._storeTimeoutId=null,this._storeUpdate=(r,s)=>{if(this.db&&s!==this){let[n]=d(this.db,[R]);l(n,r),++this._dbsize>=k&&(this._storeTimeoutId!==null&&clearTimeout(this._storeTimeoutId),this._storeTimeoutId=setTimeout(()=>{W(this,!1),this._storeTimeoutId=null},this._storeTimeout))}},o.on("update",this._storeUpdate),this.destroy=this.destroy.bind(this),o.on("destroy",this.destroy)}destroy(){return this._storeTimeoutId&&clearTimeout(this._storeTimeoutId),this.doc.off("update",this._storeUpdate),this.doc.off("destroy",this.destroy),this._destroyed=!0,this._db.then(t=>{t.close()})}clearData(){return this.destroy().then(()=>{f(this.name)})}get(t){return this._db.then(o=>{let[r]=d(o,[y],"readonly");return A(r,t)})}set(t,o){return this._db.then(r=>{let[s]=d(r,[y]);return I(s,o,t)})}del(t){return this._db.then(o=>{let[r]=d(o,[y]);return x(r,t)})}};export{S as IndexeddbPersistence,k as PREFERRED_TRIM_SIZE,Q as clearDocument,z as fetchUpdates,W as storeState}